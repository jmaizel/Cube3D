/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   attack.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 21:16:22 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/02 19:37:18 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Vérifie si un monstre est à portée d'attaque
 */
static int	is_monster_in_range(t_game *game, int monster_index)
{
	double	dx;
	double	dy;
	double	distance;

	if (!game->monsters[monster_index].alive)
		return (0);
	dx = game->monsters[monster_index].x - game->player.x;
	dy = game->monsters[monster_index].y - game->player.y;
	distance = sqrt(dx * dx + dy * dy);
	if (distance > game->weapon_range)
		return (0);
	return (is_monster_in_fov(game, dx, dy));
}

/**
 * Attaque un monstre spécifique si à portée
 */
static void	attack_monster(t_game *game, int monster_index)
{
	if (is_monster_in_range(game, monster_index))
		damage_monster(game, monster_index);
}

/**
 * Gère l'attaque du joueur contre les monstres
 */
void	attack(t_game *game)
{
	int	i;

	if (game->weapon_timer > 0)
		return ;
	init_weapon_animation(game);
	i = 0;
	while (i < game->monster_count)
	{
		attack_monster(game, i);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   attack_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 21:13:34 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/02 19:37:32 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Normalise un angle entre -PI et PI
 */
void	normalize_angle(double *angle)
{
	while (*angle > M_PI)
		*angle -= 2 * M_PI;
	while (*angle < -M_PI)
		*angle += 2 * M_PI;
}

/**
 * Initialise les états d'animation de l'arme
 */
void	init_weapon_animation(t_game *game)
{
	game->firing = 1;
	game->weapon_timer = game->weapon_cooldown;
	game->weapon_animating = 1;
	game->current_weapon_frame = 0;
	game->weapon_anim_time = 0;
}

/**
 * Vérifie si un monstre est visible dans le champ de vision
 */
int	is_monster_in_fov(t_game *game, double dx, double dy)
{
	double	angle;
	double	player_angle;
	double	angle_diff;

	angle = atan2(dy, dx);
	player_angle = atan2(game->player.dir_y, game->player.dir_x);
	normalize_angle(&angle);
	normalize_angle(&player_angle);
	angle_diff = fabs(angle - player_angle);
	if (angle_diff > M_PI)
		angle_diff = 2 * M_PI - angle_diff;
	return (angle_diff < (M_PI / 3));
}

/**
 * Applique des dégâts à un monstre
 */
void	damage_monster(t_game *game, int monster_index)
{
	game->monsters[monster_index].health -= game->weapon_damage;
	game->monsters[monster_index].hit_animation = 1;
	game->monsters[monster_index].hit_timer = 0.2;
	if (game->monsters[monster_index].health <= 0)
	{
		game->monsters[monster_index].alive = 0;
		ft_printf("Monstre %d tué!\n", monster_index);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   game_loop.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 21:38:45 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/04 12:10:12 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Gère l'affichage de l'écran de victoire
 */
static int	handle_victory_screen(t_game *game)
{
	int	start_x;
	int	start_y;

	mlx_put_image_to_window(game->mlx, game->win, game->img, 0, 0);
	if (game->victory_tex.img)
	{
		start_x = (WIN_WIDTH - game->victory_tex.width) / 2;
		start_y = (WIN_HEIGHT - game->victory_tex.height) / 2;
		mlx_put_image_to_window(game->mlx, game->win, game->victory_tex.img,
			start_x, start_y);
	}
	return (0);
}

/**
 * Boucle principale du jeu qui gère les updates et le rendu
 */
int	game_loop(t_game *game)
{
	int	victory_result;

	calculate_delta_time(game);
	update_weapon_timer(game);
	update_monster_hit_effects(game);
	update_monster_animations(game);
	check_monsters_status(game);
	if (game->victory_displayed == 2)
		return (handle_victory_screen(game));
	victory_result = check_door_victory(game);
	if (victory_result != 0)
		return (victory_result);
	update_victory_timer(game);
	handle_movement(game);
	render_frame(game);
	mlx_put_image_to_window(game->mlx, game->win, game->img, 0, 0);
	draw_controls_menu(game);
	if (game->victory_displayed == 1 || game->all_monsters_killed)
		draw_victory_message(game);
	usleep(16000);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   game_status_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 17:18:06 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/04 12:04:06 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Vérifie si tous les monstres ont été tués pour ouvrir la porte
 * 
 * @param game Structure principale du jeu
 */
void	check_monsters_status(t_game *game)
{
	if (!game->all_monsters_killed && all_monsters_dead(game))
	{
		game->all_monsters_killed = 1;
		game->door_opened = 1;
		game->victory_timer = 3.0;
		game->victory_displayed = 1;
		ft_printf("Tous les monstres sont éliminés!\n");
		ft_printf("La porte est ouverte!\n");
	}
}

/**
 * Trouve la position de la porte dans la map
 * 
 * @param game Structure principale du jeu
 * @param door_x Pointeur pour stocker la position X de la porte
 * @param door_y Pointeur pour stocker la position Y de la porte
 * @return 1 si la porte est trouvée, 0 sinon
 */
int	find_door_position(t_game *game, int *door_x, int *door_y)
{
	int	y;
	int	x;

	y = 0;
	while (y < game->map.height)
	{
		x = 0;
		while (x < (int)ft_strlen(game->map.grid[y]))
		{
			if (game->map.grid[y][x] == 'D')
			{
				*door_x = x;
				*door_y = y;
				return (1);
			}
			x++;
		}
		y++;
	}
	return (0);
}

/**
 * Affiche le message de victoire finale 
 * 
 * @param game Structure principale du jeu
 * @return 0 pour indiquer la fin du jeu
 */
int	display_victory(t_game *game)
{
	int	x;
	int	y;
	int	start_x;
	int	start_y;

	ft_printf("VICTOIRE! Vous avez traversé la porte et terminé le jeu!\n");
	game->victory_displayed = 2;
	y = -1;
	while (++y < WIN_HEIGHT)
	{
		x = -1;
		while (++x < WIN_WIDTH)
			game->img_data[y * (game->size_line / 4) + x] = 0x000000;
	}
	mlx_put_image_to_window(game->mlx, game->win, game->img, 0, 0);
	if (game->victory_tex.img)
	{
		start_x = (WIN_WIDTH - game->victory_tex.width) / 2;
		start_y = (WIN_HEIGHT - game->victory_tex.height) / 2;
		mlx_put_image_to_window(game->mlx, game->win, game->victory_tex.img,
			start_x, start_y);
	}
	ft_printf("Écran de victoire affiché. Appuyez sur ESC pour quitter.\n");
	return (0);
}

/**
 * Vérifie si le joueur a atteint la porte pour gagner
 *
 * @param game Structure principale du jeu
 * @return 0 si le jeu continue, valeur de display_victory sinon
 */
int	check_door_victory(t_game *game)
{
	int		door_x;
	int		door_y;
	double	dx;
	double	dy;
	double	distance;

	if (!game->door_opened || game->victory_displayed == 2)
		return (0);
	if (!find_door_position(game, &door_x, &door_y))
		return (0);
	dx = game->player.x - (door_x + 0.5);
	dy = game->player.y - (door_y + 0.5);
	distance = sqrt(dx * dx + dy * dy);
	if (distance < 1.0)
	{
		display_victory(game);
		return (0);
	}
	return (0);
}

/**
 * Met à jour le timer de victoire
 * 
 * @param game Structure principale du jeu
 */
void	update_victory_timer(t_game *game)
{
	if (game->victory_timer > 0)
	{
		game->victory_timer -= game->delta_time;
		if (game->victory_timer <= 0)
		{
			game->victory_timer = 0;
			if (game->victory_displayed == 1)
				game->victory_displayed = 0;
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   keyboard.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 21:36:14 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/04 12:11:25 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Gère l'appui sur une touche
 */
int	key_press(int keycode, t_game *game)
{
	if (keycode >= 0 && keycode < 256)
		game->keys[keycode] = 1;
	if (game->victory_displayed == 2)
	{
		if (keycode == 65307 || keycode == 53)
			close_window(game);
		return (0);
	}
	if (keycode == 65361 || keycode == 123)
		game->rotate_left = 1;
	else if (keycode == 65363 || keycode == 124)
		game->rotate_right = 1;
	else if (keycode == 65307 || keycode == 53)
		close_window(game);
	else if (keycode == 109 || keycode == 46)
		toggle_mouse(game);
	else if (keycode == 32 || keycode == 1)
		attack(game);
	return (0);
}

/**
 * Gère le relâchement d'une touche
 */
int	key_release(int keycode, t_game *game)
{
	if (keycode >= 0 && keycode < 256)
		game->keys[keycode] = 0;
	if (keycode == 65361 || keycode == 123)
		game->rotate_left = 0;
	else if (keycode == 65363 || keycode == 124)
		game->rotate_right = 0;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   monster_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 21:42:41 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/02 19:47:22 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Met à jour les effets de coup pour les monstres
 */
void	update_monster_hit_effects(t_game *game)
{
	int	i;

	i = 0;
	while (i < game->monster_count)
	{
		if (game->monsters[i].hit_timer > 0)
		{
			game->monsters[i].hit_timer -= game->delta_time;
			if (game->monsters[i].hit_timer <= 0)
			{
				game->monsters[i].hit_timer = 0;
				game->monsters[i].hit_animation = 0;
			}
		}
		i++;
	}
}

/**
 * Met à jour les animations des monstres
 */
void	update_monster_animations(t_game *game)
{
	int	i;

	i = 0;
	while (i < game->monster_count)
	{
		if (game->monsters[i].alive)
		{
			game->monsters[i].anim_time += game->delta_time;
			if (game->monsters[i].anim_time >= game->monsters[i].anim_speed)
			{
				game->monsters[i].anim_time -= game->monsters[i].anim_speed;
				game->monsters[i].frame = (game->monsters[i].frame + 1)
					% game->monster_frame_count;
			}
		}
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mouse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/27 15:46:34 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/02 19:36:47 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Applique la rotation à partir d'un angle
 */
static void	apply_rotation(t_game *game, double rotation_angle)
{
	double	old_dir_x;
	double	old_plane_x;

	old_dir_x = game->player.dir_x;
	old_plane_x = game->player.plane_x;
	game->player.dir_x = game->player.dir_x * cos(rotation_angle)
		- game->player.dir_y * sin(rotation_angle);
	game->player.dir_y = old_dir_x * sin(rotation_angle)
		+ game->player.dir_y * cos(rotation_angle);
	game->player.plane_x = game->player.plane_x * cos(rotation_angle)
		- game->player.plane_y * sin(rotation_angle);
	game->player.plane_y = old_plane_x * sin(rotation_angle)
		+ game->player.plane_y * cos(rotation_angle);
}

/**
 * Gère les mouvements de la souris pour contrôler la rotation du joueur
 */
int	mouse_move(int x, int y, t_game *game)
{
	int		delta_x;
	double	rotation_angle;

	if (!game->mouse_enabled)
		return (0);
	(void)y;
	game->mouse_prev_x = game->mouse_x;
	game->mouse_x = x;
	delta_x = game->mouse_x - game->mouse_prev_x;
	if (delta_x != 0)
	{
		rotation_angle = delta_x * game->mouse_sensitivity;
		apply_rotation(game, rotation_angle);
		if (game->mouse_x < 100 || game->mouse_x > WIN_WIDTH - 100)
		{
			game->mouse_x = WIN_WIDTH / 2;
			game->mouse_prev_x = WIN_WIDTH / 2;
			mlx_mouse_move(game->mlx, game->win, WIN_WIDTH / 2, WIN_HEIGHT / 2);
		}
	}
	return (0);
}

/**
 * Active ou désactive le mode de contrôle à la souris
 */
void	toggle_mouse(t_game *game)
{
	game->mouse_enabled = !game->mouse_enabled;
	if (game->mouse_enabled)
	{
		mlx_mouse_hide(game->mlx, game->win);
		mlx_mouse_move(game->mlx, game->win, WIN_WIDTH / 2, WIN_HEIGHT / 2);
		game->mouse_x = WIN_WIDTH / 2;
		game->mouse_prev_x = WIN_WIDTH / 2;
	}
	else
	{
		mlx_mouse_show(game->mlx, game->win);
	}
}

/**
 * Gère les clics de souris
 */
int	mouse_click(int button, int x, int y, t_game *game)
{
	(void)x;
	(void)y;
	if (button == 1)
		attack(game);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   movement.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 16:45:10 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/02 19:50:08 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Vérifie si une position est valide (pas de collision avec un mur)
 */
int	is_valid_position(t_game *game, double x, double y)
{
	if (x < 0 || y < 0 || (int)x >= game->map.width
		|| (int)y >= game->map.height)
		return (0);
	if (game->map.grid[(int)y][(int)x] == '1')
		return (0);
	if (game->map.grid[(int)y][(int)x] == 'D' && !game->door_opened)
		return (0);
	return (1);
}

/**
 * Déplace le joueur vers l'avant
 */
void	move_forward(t_game *game)
{
	double	new_x;
	double	new_y;

	new_x = game->player.x + game->player.dir_x * game->move_speed;
	new_y = game->player.y + game->player.dir_y * game->move_speed;
	if (is_valid_position(game, new_x, game->player.y))
		game->player.x = new_x;
	if (is_valid_position(game, game->player.x, new_y))
		game->player.y = new_y;
}

/**
 * Déplace le joueur vers l'arrière
 */
void	move_backward(t_game *game)
{
	double	new_x;
	double	new_y;

	new_x = game->player.x - game->player.dir_x * MOVE_SPEED;
	new_y = game->player.y - game->player.dir_y * MOVE_SPEED;
	if (is_valid_position(game, new_x, game->player.y))
		game->player.x = new_x;
	if (is_valid_position(game, game->player.x, new_y))
		game->player.y = new_y;
}

/**
 * Déplace le joueur vers la gauche
 */
void	move_left(t_game *game)
{
	double	new_x;
	double	new_y;

	new_x = game->player.x - game->player.plane_x * MOVE_SPEED;
	new_y = game->player.y - game->player.plane_y * MOVE_SPEED;
	if (is_valid_position(game, new_x, game->player.y))
		game->player.x = new_x;
	if (is_valid_position(game, game->player.x, new_y))
		game->player.y = new_y;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   movement_rotate.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 21:32:14 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/02 19:50:20 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Déplace le joueur vers la droite
 */
void	move_right(t_game *game)
{
	double	new_x;
	double	new_y;

	new_x = game->player.x + game->player.plane_x * MOVE_SPEED;
	new_y = game->player.y + game->player.plane_y * MOVE_SPEED;
	if (is_valid_position(game, new_x, game->player.y))
		game->player.x = new_x;
	if (is_valid_position(game, game->player.x, new_y))
		game->player.y = new_y;
}

/**
 * Fait pivoter le joueur vers la gauche
 */
void	rotate_left(t_game *game)
{
	double	old_dir_x;
	double	old_plane_x;

	old_dir_x = game->player.dir_x;
	old_plane_x = game->player.plane_x;
	game->player.dir_x = game->player.dir_x * cos(-ROT_SPEED)
		- game->player.dir_y * sin(-ROT_SPEED);
	game->player.dir_y = old_dir_x * sin(-ROT_SPEED) + game->player.dir_y
		* cos(-ROT_SPEED);
	game->player.plane_x = game->player.plane_x * cos(-ROT_SPEED)
		- game->player.plane_y * sin(-ROT_SPEED);
	game->player.plane_y = old_plane_x * sin(-ROT_SPEED) + game->player.plane_y
		* cos(-ROT_SPEED);
}

/**
 * Fait pivoter le joueur vers la droite
 */
void	rotate_right(t_game *game)
{
	double	old_dir_x;
	double	old_plane_x;

	old_dir_x = game->player.dir_x;
	old_plane_x = game->player.plane_x;
	game->player.dir_x = game->player.dir_x * cos(ROT_SPEED)
		- game->player.dir_y * sin(ROT_SPEED);
	game->player.dir_y = old_dir_x * sin(ROT_SPEED) + game->player.dir_y
		* cos(ROT_SPEED);
	game->player.plane_x = game->player.plane_x * cos(ROT_SPEED)
		- game->player.plane_y * sin(ROT_SPEED);
	game->player.plane_y = old_plane_x * sin(ROT_SPEED) + game->player.plane_y
		* cos(ROT_SPEED);
}

/**
 * Gère tous les mouvements actifs du joueur
 */
void	handle_movement(t_game *game)
{
	if (game->keys[119] || game->keys[13])
		move_forward(game);
	if (game->keys[115] || game->keys[1])
		move_backward(game);
	if (game->keys[97] || game->keys[0])
		move_left(game);
	if (game->keys[100] || game->keys[2])
		move_right(game);
	if (game->rotate_left)
		rotate_left(game);
	if (game->rotate_right)
		rotate_right(game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   movement_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 17:19:17 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/02 19:46:52 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Retourne le temps actuel en secondes avec précision microseconde
 */
double	get_time(void)
{
	struct timeval	tv;

	gettimeofday(&tv, NULL);
	return ((double)tv.tv_sec + (double)tv.tv_usec / 1000000.0);
}

/**
 * Calcule le delta time entre les frames
 */
void	calculate_delta_time(t_game *game)
{
	double	current_time;

	current_time = get_time();
	if (game->last_frame_time == 0.0)
		game->last_frame_time = current_time;
	game->delta_time = current_time - game->last_frame_time;
	game->last_frame_time = current_time;
	if (game->delta_time > 0.1)
		game->delta_time = 0.1;
}

/**
 * Met à jour le timer de l'arme
 */
void	update_weapon_timer(t_game *game)
{
	if (game->weapon_timer > 0)
	{
		game->weapon_timer -= game->delta_time;
		if (game->weapon_timer <= 0)
		{
			game->weapon_timer = 0;
			game->firing = 0;
		}
	}
	if (game->weapon_animating)
	{
		game->weapon_anim_time += game->delta_time;
		if (game->weapon_anim_time >= game->weapon_anim_speed)
		{
			game->weapon_anim_time -= game->weapon_anim_speed;
			game->current_weapon_frame++;
			if (game->current_weapon_frame >= game->weapon_frame_count)
			{
				game->current_weapon_frame = 0;
				game->weapon_animating = 0;
			}
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_enemies2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 14:30:00 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/01 09:32:20 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Vérifie si tous les monstres sont morts
 *
 * @param game Structure principale du jeu
 * @return 1 si tous les monstres sont morts, 0 sinon
 */
int	all_monsters_dead(t_game *game)
{
	int	i;

	i = 0;
	while (i < game->monster_count)
	{
		if (game->monsters[i].alive)
			return (0);
		i++;
	}
	return (1);
}

/**
 * Dessine tous les monstres à l'écran
 *
 * @param game Structure principale du jeu
 */
void	render_monsters(t_game *game)
{
	int			i;
	int			order[MAX_MONSTERS];
	double		distances[MAX_MONSTERS];
	t_sprite	sprite;

	if (game->monster_frame_count == 0)
		return ;
	sort_monsters(game, distances, order);
	i = 0;
	while (i < game->monster_count)
	{
		if (!game->monsters[order[i]].alive)
		{
			i++;
			continue ;
		}
		sprite = calc_sprite_pos(game, order, i, &sprite);
		process_monster_sprite(game, &sprite, order[i]);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_enemies.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/25 16:31:16 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/01 18:59:36 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Initialise les propriétés d'un monstre
 * 
 * @param game Structure principale du jeu
 * @param x Position X sur la map
 * @param y Position Y sur la map
 */
static void	init_monster(t_game *game, int x, int y)
{
	if (game->monster_frame_count == 0)
		ft_printf("Warning: Monstre trouvé mais pas de texture\n");
	game->monsters[game->monster_count].x = x + 0.5;
	game->monsters[game->monster_count].y = y + 0.5;
	game->monsters[game->monster_count].alive = 1;
	game->monsters[game->monster_count].frame = 0;
	game->monsters[game->monster_count].anim_time = 0.0;
	game->monsters[game->monster_count].anim_speed = 0.2;
	game->monsters[game->monster_count].health = 100;
	game->monsters[game->monster_count].max_health = 100;
	game->monsters[game->monster_count].hit_animation = 0;
	game->monsters[game->monster_count].hit_timer = 0.0;
	game->monster_count++;
	game->map.grid[y][x] = '0';
}

/**
 * Initialise les monstres dans la map
 * Recherche les positions 'M' dans la grille et crée des monstres à ces endroits
 *
 * @param game Structure principale du jeu
 */
void	init_monsters(t_game *game)
{
	int	x;
	int	y;

	game->monster_count = 0;
	y = 0;
	while (y < game->map.height)
	{
		x = 0;
		while (x < (int)ft_strlen(game->map.grid[y]))
		{
			if (game->map.grid[y][x] == 'M')
				init_monster(game, x, y);
			x++;
		}
		y++;
	}
}

/**
 * Calcule le texX pour le sprite
 * 
 * @param sprite Informations du sprite
 * @param stripe Colonne X en cours
 * @param tex_width Largeur de la texture
 * @return Coordonnée X dans la texture
 */
static int	calc_tex_x(t_sprite *sprite, int stripe, int tex_width)
{
	return ((int)(256 * (stripe - (-sprite->width / 2 + sprite->screen_x))
		* tex_width / sprite->width) / 256);
}

/**
 * Traite le sprite d'un monstre et rend sa colonne
 * 
 * @param game Structure principale du jeu
 * @param sprite Informations du sprite
 * @param monster_index Indice du monstre
 */
void	process_monster_sprite(t_game *game, t_sprite *sprite,
		int monster_index)
{
	t_draw_limits	limits;
	t_draw_params	draw;
	int				stripe;
	int				tex_x;

	calc_sprite_draw_limits(sprite, &limits);
	draw.sprite = sprite;
	stripe = limits.draw_start_x;
	while (stripe < limits.draw_end_x)
	{
		tex_x = calc_tex_x(sprite, stripe, game->monster_frames[0].width);
		if (sprite->transform_y > 0 && stripe > 0 && stripe < WIN_WIDTH
			&& sprite->transform_y < game->z_buffer[stripe])
		{
			draw.stripe = stripe;
			draw.tex_x = tex_x;
			draw.draw_start_y = limits.draw_start_y;
			draw.draw_end_y = limits.draw_end_y;
			draw_monster_column(game, draw, monster_index);
		}
		stripe++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_enemies_utils2.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 14:35:00 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/01 18:57:10 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Prépare les paramètres et appelle la fonction de dessin de pixel
 * 
 * @param game Structure principale du jeu
 * @param draw Structure contenant les paramètres de dessin
 * @param monster_index Indice du monstre dans le tableau
 */
void	draw_monster_column(t_game *game, t_draw_params draw, int monster_index)
{
	int				y;
	int				color;
	t_draw_params	params;

	params.stripe = draw.stripe;
	params.sprite = draw.sprite;
	params.tex_x = draw.tex_x;
	y = draw.draw_start_y;
	while (y < draw.draw_end_y)
	{
		params.y = y;
		color = get_monster_pixel(game, params, monster_index);
		draw_monster_pixel(game, params, color, monster_index);
		y++;
	}
}

/**
 * Calcule la position du sprite d'un monstre à l'écran
 * 
 * @param game Structure principale du jeu
 * @param order Indices des monstres triés par distance
 * @param i Indice dans le tableau order
 * @param sprite Structure pour stocker les informations du sprite
 * @return Structure contenant les informations calculées
 */
t_sprite	calc_sprite_pos(t_game *game, int *order, int i,
		t_sprite *sprite)
{
	double	inv_det;
	double	transform_x;
	double	transform_y;

	sprite->x = game->monsters[order[i]].x - game->player.x;
	sprite->y = game->monsters[order[i]].y - game->player.y;
	inv_det = 1.0 / (game->player.plane_x * game->player.dir_y
			- game->player.dir_x * game->player.plane_y);
	transform_x = inv_det * (game->player.dir_y * sprite->x
			- game->player.dir_x * sprite->y);
	transform_y = inv_det * (-game->player.plane_y * sprite->x
			+ game->player.plane_x * sprite->y);
	sprite->width = abs((int)(WIN_HEIGHT / transform_y));
	sprite->height = sprite->width;
	sprite->screen_x = (int)((WIN_WIDTH / 2) * (1 + transform_x
				/ transform_y));
	sprite->transform_y = transform_y;
	return (*sprite);
}

/**
 * Calcule les limites de dessin du sprite
 * 
 * @param sprite Informations sur le sprite
 * @param limits Structure contenant les limites à calculer
 */
void	calc_sprite_draw_limits(t_sprite *sprite, t_draw_limits *limits)
{
	limits->draw_start_y = -sprite->height / 2 + WIN_HEIGHT / 2;
	if (limits->draw_start_y < 0)
		limits->draw_start_y = 0;
	limits->draw_end_y = sprite->height / 2 + WIN_HEIGHT / 2;
	if (limits->draw_end_y >= WIN_HEIGHT)
		limits->draw_end_y = WIN_HEIGHT - 1;
	limits->draw_start_x = -sprite->width / 2 + sprite->screen_x;
	if (limits->draw_start_x < 0)
		limits->draw_start_x = 0;
	limits->draw_end_x = sprite->width / 2 + sprite->screen_x;
	if (limits->draw_end_x >= WIN_WIDTH)
		limits->draw_end_x = WIN_WIDTH - 1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_enemies_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 13:15:30 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/01 09:48:17 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Initialise le tableau des distances et des indices
 * 
 * @param game Structure principale du jeu
 * @param distances Tableau des distances au carré
 * @param order Tableau des indices
 */
static void	init_monster_order(t_game *game, double *distances, int *order)
{
	int	i;

	i = 0;
	while (i < game->monster_count)
	{
		order[i] = i;
		distances[i] = ((game->player.x - game->monsters[i].x)
				* (game->player.x - game->monsters[i].x)
				+ (game->player.y - game->monsters[i].y)
				* (game->player.y - game->monsters[i].y));
		i++;
	}
}

/**
 * Trie les monstres par distance pour le rendu
 * Utilise un tri à bulles pour trier du plus éloigné au plus proche
 * 
 * @param game Structure principale du jeu
 * @param distances Tableau des distances au carré entre joueur et monstres
 * @param order Tableau des indices triés par distance
 */
void	sort_monsters(t_game *game, double *distances, int *order)
{
	int		i;
	int		j;
	int		tmp;
	double	tmp_dist;

	init_monster_order(game, distances, order);
	i = 0;
	while (i < game->monster_count - 1)
	{
		j = 0;
		while (j < game->monster_count - i - 1)
		{
			if (distances[j] < distances[j + 1])
			{
				tmp_dist = distances[j];
				distances[j] = distances[j + 1];
				distances[j + 1] = tmp_dist;
				tmp = order[j];
				order[j] = order[j + 1];
				order[j + 1] = tmp;
			}
			j++;
		}
		i++;
	}
}

/**
 * Applique l'effet de coup quand un monstre est touché
 * 
 * @param color Couleur originale
 * @param is_hit État d'animation de coup
 * @return Couleur modifiée
 */
static int	apply_hit_effect(int color, int is_hit)
{
	int	red;

	if (!is_hit)
		return (color);
	red = (color >> 16) & 0xFF;
	red = fmin(255, red + 100);
	return ((red << 16) | (color & 0x00FFFF));
}

/**
 * Dessine un pixel de monstre si la couleur n'est pas noire (transparente)
 * 
 * @param game Structure principale du jeu
 * @param params Structure contenant les paramètres de dessin
 * @param color Couleur du pixel
 * @param monster_index Indice du monstre
 */
void	draw_monster_pixel(t_game *game, t_draw_params params,
		int color, int monster_index)
{
	if ((color & 0x00FFFFFF) != 0x000000)
	{
		color = apply_hit_effect(color,
				game->monsters[monster_index].hit_animation);
		game->img_data[params.y * (game->size_line / 4)
			+ params.stripe] = color;
	}
}

/**
 * Récupère la couleur d'un pixel de la texture du monstre
 * 
 * @param game Structure principale du jeu
 * @param params Structure contenant les paramètres de dessin
 * @param monster_index Indice du monstre
 * @return Couleur du pixel ou 0 si hors limites
 */
int	get_monster_pixel(t_game *game, t_draw_params params,
		int monster_index)
{
	int	frame;
	int	tex_y;
	int	d;

	frame = game->monsters[monster_index].frame;
	if (frame >= game->monster_frame_count)
		frame = 0;
	d = (params.y) * 256 - WIN_HEIGHT * 128 + params.sprite->height * 128;
	tex_y = ((d * game->monster_frames[frame].height)
			/ params.sprite->height) / 256;
	if (tex_y >= 0 && tex_y < game->monster_frames[frame].height
		&& params.tex_x >= 0 && params.tex_x
		< game->monster_frames[frame].width)
	{
		return (game->monster_frames[frame].data[game->monster_frames
				[frame].width * tex_y + params.tex_x]);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_menu.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/28 17:34:40 by cdedessu          #+#    #+#             */
/*   Updated: 2025/04/30 17:33:03 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Dessine un élément de contrôle dans le menu (touche + action)
 * 
 * @param game Structure principale du jeu
 * @param pos_y Position Y où dessiner l'élément
 * @param key_str Chaîne décrivant la touche
 * @param action_str Chaîne décrivant l'action
 */
static void	draw_control_item(t_game *game, int pos_y, char *key_str,
		char *action_str)
{
	int	x_start;
	int	key_color;
	int	action_color;
	int	key_len;

	x_start = WIN_WIDTH - 300;
	key_color = 0x00FFFF;
	action_color = 0xFFFFFF;
	key_len = ft_strlen(key_str) * 6;
	mlx_string_put(game->mlx, game->win, x_start, pos_y, key_color, key_str);
	mlx_string_put(game->mlx, game->win, x_start + key_len, pos_y,
		action_color, action_str);
}

/**
 * Dessine le menu des contrôles dans le coin supérieur droit de l'écran
 * 
 * @param game Structure principale du jeu
 */
void	draw_controls_menu(t_game *game)
{
	int	x_start;
	int	y_start;
	int	line_height;
	int	i;
	int	title_color;

	x_start = WIN_WIDTH - 300;
	y_start = 20;
	line_height = 20;
	i = 0;
	title_color = 0xFFFF00;
	mlx_string_put(game->mlx, game->win, x_start, y_start + line_height * i++,
		title_color, "CONTROLS:");
	draw_control_item(game, y_start + line_height * i++, "WASD:", "Move");
	draw_control_item(game, y_start + line_height * i++, "Arrows/Mouse:",
		"Look");
	draw_control_item(game, y_start + line_height * i++, "M:",
		"Toggle mouse");
	draw_control_item(game, y_start + line_height * i++, "LMB/Space:",
		"Shoot");
	draw_control_item(game, y_start + line_height * i++, "ESC:", "Quit");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_minimap.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/02 14:10:35 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/01 19:13:32 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Détermine la couleur d'une cellule sur la minimap
 * 
 * @param game Structure principale du jeu
 * @param map_y Position Y dans la map
 * @param map_x Position X dans la map
 * @return Couleur de la cellule ou -1 si à ignorer
 */
static int	get_cell_color(t_game *game, int map_y, int map_x)
{
	char	cell_type;

	cell_type = game->map.grid[map_y][map_x];
	if (cell_type == '1')
		return (MAP_WALL_COLOR);
	else if (cell_type == '0' || ft_strchr("NSEWDMP", cell_type))
		return (MAP_FLOOR_COLOR);
	return (-1);
}

/**
 * Dessine les cases (murs et sol) sur la minimap
 * 
 * @param game Structure principale du jeu
 * @param pos Position de la minimap
 */
static void	draw_map_cells(t_game *game, t_minimap_pos pos)
{
	int				map_y;
	int				map_x;
	t_minimap_pos	cell_pos;
	int				color;

	map_y = 0;
	while (map_y < game->map.height)
	{
		map_x = 0;
		while (map_x < (int)ft_strlen(game->map.grid[map_y]))
		{
			color = get_cell_color(game, map_y, map_x);
			if (color != -1)
			{
				cell_pos.x = pos.x + map_x * pos.cell_size;
				cell_pos.y = pos.y + map_y * pos.cell_size;
				cell_pos.cell_size = pos.cell_size;
				draw_cell(game, cell_pos, color);
			}
			map_x++;
		}
		map_y++;
	}
}

/**
 * Dessine le joueur et sa direction sur la minimap
 * 
 * @param game Structure principale du jeu
 * @param pos Position de la minimap
 */
static void	draw_player(t_game *game, t_minimap_pos pos)
{
	t_line	line;
	int		player_x;
	int		player_y;

	player_x = pos.x + (int)(game->player.x * pos.cell_size);
	player_y = pos.y + (int)(game->player.y * pos.cell_size);
	draw_player_dot(game, player_x, player_y, MAP_PLAYER_COLOR);
	line.x0 = player_x;
	line.y0 = player_y;
	line.x1 = player_x + (int)(game->player.dir_x * pos.cell_size * 2);
	line.y1 = player_y + (int)(game->player.dir_y * pos.cell_size * 2);
	draw_line(game, line, MAP_PLAYER_COLOR);
}

/**
 * Calcule les dimensions de la minimap
 * 
 * @param game Structure principale du jeu
 * @param pos Structure contenant la position de la minimap
 * @return Structure contenant les dimensions de la minimap
 */
static t_minimap_size	calculate_minimap_size(t_game *game,
		t_minimap_pos *pos)
{
	t_minimap_size	size;
	int				max_width;

	size.width = game->map.width * pos->cell_size;
	size.height = game->map.height * pos->cell_size;
	max_width = WIN_WIDTH / 4;
	if (size.width > max_width)
	{
		pos->cell_size = max_width / game->map.width;
		size.width = game->map.width * pos->cell_size;
		size.height = game->map.height * pos->cell_size;
	}
	return (size);
}

/**
 * Dessine la minimap en haut à gauche de l'écran
 * 
 * @param game Structure principale du jeu
 */
void	draw_minimap(t_game *game)
{
	t_minimap_pos	pos;
	t_minimap_size	size;

	pos.cell_size = 6;
	pos.x = 20;
	pos.y = 20;
	size = calculate_minimap_size(game, &pos);
	draw_minimap_background(game, pos, size);
	draw_map_cells(game, pos);
	draw_player(game, pos);
	draw_minimap_border(game, pos, size);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_minimap_utils2.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 18:10:30 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/01 19:17:33 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Dessine un point représentant le joueur
 * 
 * @param game Structure principale du jeu
 * @param x Position X du joueur
 * @param y Position Y du joueur
 * @param color Couleur du joueur
 */
void	draw_player_dot(t_game *game, int x, int y, int color)
{
	int	i;
	int	j;

	i = -2;
	while (i <= 2)
	{
		j = -2;
		while (j <= 2)
		{
			if (i * i + j * j <= 4)
			{
				if (y + i >= 0 && y + i < WIN_HEIGHT && x + j >= 0
					&& x + j < WIN_WIDTH)
					game->img_data[(y + i) * (game->size_line / 4)
						+ (x + j)] = color;
			}
			j++;
		}
		i++;
	}
}

/**
 * Dessine les bordures horizontales de la minimap
 * 
 * @param game Structure principale du jeu
 * @param pos Position de la minimap
 * @param size Dimensions de la minimap
 * @param color Couleur de la bordure
 */
static void	draw_horizontal_borders(t_game *game, t_minimap_pos pos,
		t_minimap_size size, int color)
{
	int	i;
	int	border_size;

	border_size = 1;
	i = -border_size;
	while (i < size.width + border_size)
	{
		if (pos.y - border_size >= 0 && pos.x + i >= 0
			&& pos.y - border_size < WIN_HEIGHT && pos.x + i < WIN_WIDTH)
			game->img_data[(pos.y - border_size) * (game->size_line / 4)
				+ (pos.x + i)] = color;
		if (pos.y + size.height >= 0 && pos.x + i >= 0
			&& pos.y + size.height < WIN_HEIGHT && pos.x + i < WIN_WIDTH)
			game->img_data[(pos.y + size.height) * (game->size_line / 4)
				+ (pos.x + i)] = color;
		i++;
	}
}

/**
 * Dessine les bordures verticales de la minimap
 * 
 * @param game Structure principale du jeu
 * @param pos Position de la minimap
 * @param size Dimensions de la minimap
 * @param color Couleur de la bordure
 */
static void	draw_vertical_borders(t_game *game, t_minimap_pos pos,
		t_minimap_size size, int color)
{
	int	i;
	int	border_size;

	border_size = 1;
	i = -border_size;
	while (i < size.height + border_size)
	{
		if (pos.y + i >= 0 && pos.x - border_size >= 0
			&& pos.y + i < WIN_HEIGHT && pos.x - border_size < WIN_WIDTH)
			game->img_data[(pos.y + i) * (game->size_line / 4)
				+ (pos.x - border_size)] = color;
		if (pos.y + i >= 0 && pos.x + size.width >= 0
			&& pos.y + i < WIN_HEIGHT && pos.x + size.width < WIN_WIDTH)
			game->img_data[(pos.y + i) * (game->size_line / 4)
				+ (pos.x + size.width)] = color;
		i++;
	}
}

/**
 * Dessine un cadre autour de la minimap
 * 
 * @param game Structure principale du jeu
 * @param pos Position de la minimap
 * @param size Dimensions de la minimap
 */
void	draw_minimap_border(t_game *game, t_minimap_pos pos,
		t_minimap_size size)
{
	draw_horizontal_borders(game, pos, size, MAP_BORDER_COLOR);
	draw_vertical_borders(game, pos, size, MAP_BORDER_COLOR);
}

/**
 * Dessine le fond de la minimap
 * 
 * @param game Structure principale du jeu
 * @param pos Position de la minimap
 * @param size Dimensions de la minimap
 */
void	draw_minimap_background(t_game *game, t_minimap_pos pos,
		t_minimap_size size)
{
	int	x;
	int	y;

	y = 0;
	while (y < size.height)
	{
		x = 0;
		while (x < size.width)
		{
			if (pos.y + y < WIN_HEIGHT && pos.x + x < WIN_WIDTH)
				game->img_data[(pos.y + y) * (game->size_line / 4)
					+ (pos.x + x)] = MAP_BG_COLOR;
			x++;
		}
		y++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_minimap_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 18:05:30 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/01 19:03:19 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Calcule le delta et les signes pour l'algorithme de Bresenham
 * 
 * @param line Structure contenant les coordonnées de la ligne
 * @param delta Structure à remplir avec les deltas
 * @param sign Structure à remplir avec les signes
 */
static void	init_line_params(t_line line, t_line *delta, t_line *sign)
{
	delta->x0 = abs(line.x1 - line.x0);
	delta->y0 = abs(line.y1 - line.y0);
	if (line.x0 < line.x1)
		sign->x0 = 1;
	else
		sign->x0 = -1;
	if (line.y0 < line.y1)
		sign->y0 = 1;
	else
		sign->y0 = -1;
}

/**
 * Dessine un point à l'écran si les coordonnées sont valides
 * 
 * @param game Structure principale du jeu
 * @param x Coordonnée X du point
 * @param y Coordonnée Y du point
 * @param color Couleur du point
 */
static void	draw_point(t_game *game, int x, int y, int color)
{
	if (x >= 0 && y >= 0 && x < WIN_WIDTH && y < WIN_HEIGHT)
		game->img_data[y * (game->size_line / 4) + x] = color;
}

/**
 * Dessine une ligne entre deux points (algorithme de Bresenham)
 * 
 * @param game Structure principale du jeu
 * @param line Structure contenant les coordonnées de la ligne
 * @param color Couleur de la ligne
 */
void	draw_line(t_game *game, t_line line, int color)
{
	t_line	delta;
	t_line	sign;
	int		err;
	int		e2;

	init_line_params(line, &delta, &sign);
	err = delta.x0 - delta.y0;
	draw_point(game, line.x0, line.y0, color);
	while (line.x0 != line.x1 || line.y0 != line.y1)
	{
		e2 = 2 * err;
		if (e2 > -delta.y0)
		{
			err -= delta.y0;
			line.x0 += sign.x0;
		}
		if (e2 < delta.x0)
		{
			err += delta.x0;
			line.y0 += sign.y0;
		}
		draw_point(game, line.x0, line.y0, color);
	}
}

/**
 * Dessine une cellule de la minimap
 * 
 * @param game Structure principale du jeu
 * @param pos Structure contenant la position de la cellule
 * @param size Taille de la cellule
 * @param color Couleur de la cellule
 */
void	draw_cell(t_game *game, t_minimap_pos pos, int color)
{
	int	i;
	int	j;

	i = 1;
	while (i < pos.cell_size - 1)
	{
		j = 1;
		while (j < pos.cell_size - 1)
		{
			if (pos.y + i < WIN_HEIGHT && pos.x + j < WIN_WIDTH)
				game->img_data[(pos.y + i) * (game->size_line / 4)
					+ (pos.x + j)] = color;
			j++;
		}
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw_weapon.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/02 14:10:35 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/01 19:22:12 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Détermine la frame actuelle pour l'animation de l'arme
 * 
 * @param game Structure principale du jeu
 * @return Indice de la frame actuelle
 */
static int	get_current_weapon_frame(t_game *game)
{
	int	current_frame;

	if (game->weapon_animating)
		current_frame = game->current_weapon_frame;
	else
		current_frame = 0;
	return (current_frame);
}

/**
 * Initialise les positions pour le dessin de l'arme
 * 
 * @param game Structure principale du jeu
 * @param current_frame Indice de la frame actuelle
 * @param params Structure à remplir avec les paramètres
 */
static void	init_weapon_draw_params(t_game *game, int current_frame,
		t_weapon_draw *params)
{
	params->start_x = WIN_WIDTH / 2
		- game->weapon_frames[current_frame].width / 2 + 30;
	params->start_y = WIN_HEIGHT
		- game->weapon_frames[current_frame].height + 10;
}

/**
 * Dessine un pixel de l'arme à la position spécifiée
 * 
 * @param game Structure principale du jeu
 * @param params Paramètres de dessin
 */
static void	draw_weapon_pixel(t_game *game, t_weapon_draw params)
{
	if (params.draw_x >= 0 && params.draw_x < WIN_WIDTH
		&& params.draw_y >= 0 && params.draw_y < WIN_HEIGHT)
		game->img_data[params.draw_y * (game->size_line / 4)
			+ params.draw_x] = params.color;
}

/**
 * Dessine l'arme du joueur en bas de l'écran avec animation
 * Utilise la frame actuelle de l'animation déterminée par weapon_animating
 *
 * @param game Structure principale du jeu
 */
void	draw_weapon(t_game *game)
{
	t_weapon_draw	params;
	int				current_frame;

	current_frame = get_current_weapon_frame(game);
	if (!game->weapon_frames[current_frame].data)
		return ;
	init_weapon_draw_params(game, current_frame, &params);
	params.y = 0;
	while (params.y < game->weapon_frames[current_frame].height)
	{
		params.x = 0;
		while (params.x < game->weapon_frames[current_frame].width)
		{
			params.color = game->weapon_frames[current_frame].data[params.y
				* game->weapon_frames[current_frame].width + params.x];
			if ((params.color & 0x00FFFFFF) != 0x000000)
			{
				params.draw_x = params.start_x + params.x;
				params.draw_y = params.start_y + params.y;
				draw_weapon_pixel(game, params);
			}
			params.x++;
		}
		params.y++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render_frame.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/25 14:00:00 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/01 19:23:31 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render_frame.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/25 14:00:00 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/01 14:09:30 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Dessine le sol et le plafond de la scène 3D
 * 
 * @param game Structure principale du jeu
 */
static void	draw_floor_ceiling(t_game *game)
{
	int	x;
	int	y;

	y = 0;
	while (y < WIN_HEIGHT)
	{
		x = 0;
		while (x < WIN_WIDTH)
		{
			if (y < WIN_HEIGHT / 2)
				game->img_data[y * (game->size_line / 4)
					+ x] = game->ceiling_color;
			else
				game->img_data[y * (game->size_line / 4)
					+ x] = game->floor_color;
			x++;
		}
		y++;
	}
}

/**
 * Dessine une frame complète avec sol, plafond, murs, minimap et arme
 * 
 * @param game Structure principale du jeu
 */
void	render_frame(t_game *game)
{
	draw_floor_ceiling(game);
	complete_raycasting(game);
	render_monsters(game);
	draw_minimap(game);
	draw_weapon(game);
	draw_controls_menu(game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   textures2.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 19:30:00 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/06 11:38:24 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Charge les textures des murs
 *
 * @param game Structure principale du jeu
 * @return 1 si réussi, 0 sinon
 */
static int	load_wall_textures(t_game *game)
{
	if (!load_texture(game, &game->north_tex, (char *)game->north_tex.img))
		return (0);
	if (!load_texture(game, &game->south_tex, (char *)game->south_tex.img))
		return (0);
	if (!load_texture(game, &game->east_tex, (char *)game->east_tex.img))
		return (0);
	if (!load_texture(game, &game->west_tex, (char *)game->west_tex.img))
		return (0);
	if (game->door_tex.img && !load_texture(game, &game->door_tex,
			(char *)game->door_tex.img))
		return (0);
	return (1);
}

/**
 * Charge les textures des armes
 *
 * @param game Structure principale du jeu
 * @return 1 si réussi, 0 sinon
 */
static int	load_weapon_textures(t_game *game)
{
	int	i;

	i = 0;
	while (i < game->weapon_frame_count)
	{
		if (game->weapon_paths[i] && !load_texture(game,
				&game->weapon_frames[i], game->weapon_paths[i]))
			return (0);
		free(game->weapon_paths[i]);
		game->weapon_paths[i] = NULL;
		i++;
	}
	return (1);
}

/**
 * Charge les textures des monstres
 *
 * @param game Structure principale du jeu
 * @return 1 si réussi, 0 sinon
 */
static int	load_monster_textures(t_game *game)
{
	int	i;

	i = 0;
	while (i < game->monster_frame_count)
	{
		if (game->monster_paths[i] && !load_texture(game,
				&game->monster_frames[i], game->monster_paths[i]))
			return (0);
		free(game->monster_paths[i]);
		game->monster_paths[i] = NULL;
		i++;
	}
	return (1);
}

/**
 * Charge toutes les textures nécessaires au jeu
 *
 * @param game Structure principale du jeu
 * @return 1 si toutes les textures ont été chargées, 0 sinon
 */
int	load_all_textures(t_game *game)
{
	if (!load_wall_textures(game))
		return (0);
	if (!load_weapon_textures(game))
		return (0);
	if (!load_monster_textures(game))
		return (0);
	if (!load_texture(game, &game->victory_tex, "./textures/victory.xpm"))
		return (0);
	free_texture_paths(game);
	return (1);
}

/**
 * Calcule et dessine une colonne de pixel texturée pour un mur
 *
 * @param x Coordonnée X de la colonne à dessiner
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 */
void	draw_textured_line(int x, t_ray *ray, t_game *game)
{
	t_texture		*tex;
	t_tex_params	params;
	int				y;
	int				tex_y;
	int				color;

	if (ray->hit_type == 2 || ray->hit_type == 3)
		tex = &game->door_tex;
	else
		get_texture(ray, game, &tex);
	prepare_texture_params(ray, tex, &params);
	y = ray->draw_start;
	while (y < ray->draw_end)
	{
		tex_y = (int)params.tex_pos & (tex->height - 1);
		params.tex_pos += params.step;
		color = tex->data[tex_y * tex->width + params.tex_x];
		if (ray->side == 1 && ray->hit_type < 2)
			color = apply_side_shading(color);
		if (ray->hit_type == 3)
			color = change_door_color(color);
		game->img_data[y * (game->size_line / 4) + x] = color;
		y++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   textures.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 14:22:34 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/06 11:37:40 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Détermine quelle texture utiliser selon le côté du mur touché
 *
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 * @param tex Pointeur sur pointeur pour stocker la texture sélectionnée
 */
void	get_texture(t_ray *ray, t_game *game, t_texture **tex)
{
	if (ray->side == 0)
	{
		if (ray->dir_x > 0)
			*tex = &game->east_tex;
		else
			*tex = &game->west_tex;
	}
	else
	{
		if (ray->dir_y > 0)
			*tex = &game->south_tex;
		else
			*tex = &game->north_tex;
	}
}

/**
 * Calcule la coordonnée X de la texture pour le mur touché
 *
 * @param ray Structure contenant les informations du rayon
 * @param wall_x Pointeur pour stocker la position exacte du point de collision
 * @param tex_x Pointeur pour stocker la coordonnée X de la texture
 * @param tex Texture à utiliser
 */
void	calculate_texture_x(t_ray *ray, double *wall_x, int *tex_x,
		t_texture *tex)
{
	if (ray->side == 0)
		*wall_x = ray->pos_y + ray->perp_wall_dist * ray->dir_y;
	else
		*wall_x = ray->pos_x + ray->perp_wall_dist * ray->dir_x;
	*wall_x -= floor(*wall_x);
	*tex_x = (int)(*wall_x * (double)tex->width);
	if ((ray->side == 0 && ray->dir_x < 0) || (ray->side == 1
			&& ray->dir_y > 0))
		*tex_x = tex->width - *tex_x - 1;
}

/**
 * Charge une texture depuis un fichier XPM
 *
 * @param game Structure principale du jeu
 * @param texture Structure pour stocker la texture chargée
 * @param path Chemin vers le fichier XPM
 * @return 1 si le chargement a réussi, 0 sinon
 */
int	load_texture(t_game *game, t_texture *texture, char *path)
{
	char	*original_path;

	while (*path && (*path == ' ' || *path == '\t'))
		path++;
	original_path = (char *)texture->img;
	texture->img = mlx_xpm_file_to_image(game->mlx, path, &texture->width,
			&texture->height);
	if (!texture->img)
		return (exit_error("Erreur: Impossible de charger la texture"), 0);
	if (original_path)
		free(original_path);
	texture->data = (int *)mlx_get_data_addr(texture->img, &texture->bpp,
			&texture->size_line, &texture->endian);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   textures_utils2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 19:38:21 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/01 19:38:37 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Prépare les paramètres pour le dessin d'une ligne texturée
 *
 * @param ray Structure du rayon
 * @param tex Texture à utiliser
 * @param params Structure pour stocker les paramètres calculés
 */
void	prepare_texture_params(t_ray *ray, t_texture *tex, t_tex_params *params)
{
	double	wall_x;
	int		tex_x;

	calculate_texture_x(ray, &wall_x, &tex_x, tex);
	params->step = 1.0 * tex->height / ray->line_height;
	params->tex_pos = (ray->draw_start - WIN_HEIGHT / 2
			+ ray->line_height / 2) * params->step;
	params->tex_x = tex_x;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   textures_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 17:50:20 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/06 11:41:07 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Applique un effet d'assombrissement aux murs côté Y
 *
 * @param color Couleur d'origine
 * @return Couleur assombrie
 */
int	apply_side_shading(int color)
{
	return ((color >> 1) & 0x7F7F7F);
}

/**
 * Applique un changement de couleur sur les portes ouvertes
 *
 * @param color Couleur d'origine
 * @return Couleur verte
 */
int	change_door_color(int color)
{
	int	red;
	int	green;
	int	blue;
	int	new_green;
	int	new_red;

	red = ((color >> 16) & 0xFF);
	green = ((color >> 8) & 0xFF);
	blue = (color & 0xFF);
	if ((red > green && red > blue) || (red > 60 && red > green * 1.5
			&& red > blue * 1.5))
	{
		new_green = red * 1.2;
		if (new_green > 255)
			new_green = 255;
		new_red = green * 0.7;
		return ((new_red << 16) | (new_green << 8) | blue);
	}
	return (color);
}

/**
 * Libère la mémoire des chemins de textures après leur chargement
 *
 * @param game Structure principale du jeu
 */
void	free_texture_paths(t_game *game)
{
	int	i;

	i = 0;
	while (i < game->weapon_frame_count)
	{
		if (game->weapon_paths[i])
		{
			free(game->weapon_paths[i]);
			game->weapon_paths[i] = NULL;
		}
		i++;
	}
	i = 0;
	while (i < game->monster_frame_count)
	{
		if (game->monster_paths[i])
		{
			free(game->monster_paths[i]);
			game->monster_paths[i] = NULL;
		}
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cleanup.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/06 11:41:47 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/06 12:11:03 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Nettoie les ressources allouées pendant la phase de configuration
 */
void	cleanup_config_resources(t_game *game)
{
	int	i;

	if (game->north_tex.img && !game->mlx)
		free(game->north_tex.img);
	if (game->south_tex.img && !game->mlx)
		free(game->south_tex.img);
	if (game->east_tex.img && !game->mlx)
		free(game->east_tex.img);
	if (game->west_tex.img && !game->mlx)
		free(game->west_tex.img);
	if (game->door_tex.img && !game->mlx)
		free(game->door_tex.img);
	i = 0;
	while (i < 4)
	{
		if (game->weapon_paths[i])
			free(game->weapon_paths[i]);
		i++;
	}
	i = 0;
	while (i++ < 4)
	{
		if (game->monster_paths[i])
			free(game->monster_paths[i]);
	}
}

/**
 * Libère les textures des murs
 */
static void	free_wall_textures(t_game *game)
{
	if (game->north_tex.img)
		mlx_destroy_image(game->mlx, game->north_tex.img);
	if (game->south_tex.img)
		mlx_destroy_image(game->mlx, game->south_tex.img);
	if (game->east_tex.img)
		mlx_destroy_image(game->mlx, game->east_tex.img);
	if (game->west_tex.img)
		mlx_destroy_image(game->mlx, game->west_tex.img);
	if (game->door_tex.img)
		mlx_destroy_image(game->mlx, game->door_tex.img);
}

/**
 * Libère les textures des armes
 */
static void	free_weapon_textures(t_game *game)
{
	int	i;

	i = 0;
	while (i < game->weapon_frame_count)
	{
		if (game->weapon_frames[i].img)
			mlx_destroy_image(game->mlx, game->weapon_frames[i].img);
		if (game->weapon_paths[i])
			free(game->weapon_paths[i]);
		i++;
	}
}

/**
 * Libère les textures des monstres
 */
static void	free_monster_textures(t_game *game)
{
	int	i;

	i = 0;
	while (i < game->monster_frame_count)
	{
		if (game->monster_frames[i].img)
			mlx_destroy_image(game->mlx, game->monster_frames[i].img);
		if (game->monster_paths[i])
			free(game->monster_paths[i]);
		i++;
	}
}

/**
 * Ferme la fenêtre et libère toutes les ressources allouées
 *
 * @param game Structure principale du jeu
 * @return 0 (toujours)
 */
int	close_window(t_game *game)
{
	free_wall_textures(game);
	free_weapon_textures(game);
	free_monster_textures(game);
	if (game->victory_tex.img)
		mlx_destroy_image(game->mlx, game->victory_tex.img);
	if (game->img)
		mlx_destroy_image(game->mlx, game->img);
	if (game->win)
		mlx_destroy_window(game->mlx, game->win);
	if (game->mlx)
		mlx_destroy_display(game->mlx);
	free(game->mlx);
	free_map(game->map.grid);
	exit(0);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/28 14:37:18 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/05 14:28:32 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Initialise les paramètres de l'arme et du jeu
 *
 * @param game Structure principale du jeu
 */
static void	init_game_part_two(t_game *game)
{
	game->weapon_damage = 25;
	game->weapon_range = 2.0;
	game->weapon_frame_count = 0;
	game->current_weapon_frame = 0;
	game->weapon_animating = 0;
	game->weapon_anim_time = 0;
	game->weapon_anim_speed = 0.1;
	game->door_opened = 0;
	game->all_monsters_killed = 0;
	game->victory_displayed = 0;
	game->victory_timer = 0.0;
	game->victory_final = 0;
	game->victory_tex.img = NULL;
}

/**
 * Initialise la structure du jeu
 *
 * @param game Structure principale du jeu
 */
static void	init_game_structure(t_game *game)
{
	int	i;

	ft_memset(game, 0, sizeof(t_game));
	i = 0;
	while (i < 4)
	{
		game->weapon_paths[i] = NULL;
		game->monster_paths[i] = NULL;
		i++;
	}
	game->rotate_left = 0;
	game->rotate_right = 0;
	game->move_speed = 0.13;
	game->rot_speed = 0.03;
	game->monster_frame_count = 0;
	game->last_frame_time = 0.0;
	game->delta_time = 0.0;
	game->mouse_enabled = 0;
	game->mouse_sensitivity = 0.002;
	game->mouse_x = WIN_WIDTH / 2;
	game->mouse_prev_x = WIN_WIDTH / 2;
	game->firing = 0;
	game->weapon_cooldown = 0.5;
	game->weapon_timer = 0.0;
	init_game_part_two(game);
}

/**
 * Initialise les hooks pour la gestion des événements
 *
 * @param game Structure principale du jeu
 */
static void	setup_hooks(t_game *game)
{
	mlx_hook(game->win, 2, 1L << 0, key_press, game);
	mlx_hook(game->win, 3, 1L << 1, key_release, game);
	mlx_hook(game->win, 17, 0, close_window, game);
	mlx_hook(game->win, 6, 1L << 6, mouse_move, game);
	mlx_mouse_hook(game->win, mouse_click, game);
	mlx_loop_hook(game->mlx, game_loop, game);
}

/**
 * Initialise l'environnement MLX et les ressources graphiques
 *
 * @param game Structure principale du jeu
 * @return 1 en cas de succès, 0 en cas d'erreur
 */
static int	init_graphics(t_game *game)
{
	game->mlx = mlx_init();
	if (!game->mlx)
		return (exit_error("Erreur init MLX"), 0);
	if (!load_all_textures(game))
		return (0);
	game->win = mlx_new_window(game->mlx, WIN_WIDTH, WIN_HEIGHT,
			"Cub3D avec raycasting");
	if (!game->win)
		return (exit_error("Erreur fenêtre"), 0);
	game->img = mlx_new_image(game->mlx, WIN_WIDTH, WIN_HEIGHT);
	game->img_data = (int *)mlx_get_data_addr(game->img, &game->bpp,
			&game->size_line, &game->endian);
	return (1);
}

/**
 * Point d'entrée principal du programme
 *
 * @param argc Nombre d'arguments
 * @param argv Tableau des arguments
 * @return 0 en cas de succès, 1 en cas d'erreur
 */
int	main(int argc, char **argv)
{
	t_game	game;

	if (argc != 2)
		return (exit_error("Usage: ./cub3D map.cub"), 1);
	init_game_structure(&game);
	if (!parse_cub_file(argv[1], &game))
		return (1);
	init_monsters(&game);
	if (!init_graphics(&game))
		return (1);
	render_frame(&game);
	mlx_put_image_to_window(game.mlx, game.win, game.img, 0, 0);
	setup_hooks(&game);
	mlx_loop(game.mlx);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 11:12:03 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/06 11:51:48 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Libère la mémoire allouée pour la map
 *
 * @param map Tableau 2D représentant la map
 */
void	free_map(char **map)
{
	int	i;

	i = 0;
	if (!map)
		return ;
	while (map[i])
	{
		free(map[i]);
		i++;
	}
	free(map);
}

/**
 * Affiche un message d'erreur et retourne 0
 *
 * @param msg Message d'erreur à afficher
 * @return 0 (toujours)
 */
int	exit_error(char *msg)
{
	ft_printf("%s\n", msg);
	return (0);
}

/**
 * Affiche les messages de victoire finale
 *
 * @param game Structure principale du jeu
 * @param msg_x Position X du message
 * @param msg_y Position Y du message
 * @param color Couleur du message
 */
static void	draw_final_victory(t_game *game, int msg_x, int msg_y, int color)
{
	mlx_string_put(game->mlx, game->win, msg_x, msg_y - 40, 0xFFFF00,
		"FÉLICITATIONS!");
	mlx_string_put(game->mlx, game->win, msg_x, msg_y, 0xFFFF00,
		"VOUS AVEZ TERMINÉ LE JEU!");
	mlx_string_put(game->mlx, game->win, msg_x, msg_y + 40, color,
		"Appuyez sur ESC pour quitter");
}

/**
 * Affiche un message de victoire quand tous les monstres sont éliminés
 *
 * @param game Structure principale du jeu
 */
void	draw_victory_message(t_game *game)
{
	int	msg_x;
	int	msg_y;
	int	color;

	msg_x = WIN_WIDTH / 2 - 150;
	msg_y = WIN_HEIGHT / 2;
	color = 0xFF0000;
	if (game->victory_displayed)
	{
		if (game->victory_final)
			draw_final_victory(game, msg_x, msg_y, color);
		else
		{
			mlx_string_put(game->mlx, game->win, WIN_WIDTH - 300, WIN_HEIGHT
				- 60, color, "TOUS LES MONSTRES SONT ELIMINÉS!");
			mlx_string_put(game->mlx, game->win, WIN_WIDTH - 300, WIN_HEIGHT
				- 40, color, "LA PORTE EST OUVERTE!");
		}
	}
	else if (game->all_monsters_killed && game->door_opened)
	{
		mlx_string_put(game->mlx, game->win, 30, WIN_HEIGHT - 30, color,
			"Porte ouverte - Traversez-la pour terminer");
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_map.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/31 12:11:54 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/05/06 11:43:02 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Trouve la largeur maximale dans un tableau de lignes de map
 */
int	find_max_width(char **map_lines)
{
	int	i;
	int	max;
	int	len;

	i = 0;
	max = 0;
	while (map_lines[i])
	{
		len = ft_strlen(map_lines[i]);
		if (len > max)
			max = len;
		i++;
	}
	return (max);
}

/**
 * Alloue et remplit la structure de map
 */
static int	build_map_structure(t_game *game, char **lines, int start_index,
		int map_lines)
{
	int	i;
	int	j;

	game->map.grid = malloc(sizeof(char *) * (map_lines + 1));
	if (!game->map.grid)
		return (0);
	i = start_index;
	j = 0;
	while (j < map_lines && lines[i])
	{
		if (is_map_line(lines[i]))
		{
			game->map.grid[j] = ft_strdup(lines[i]);
			j++;
		}
		i++;
	}
	game->map.grid[j] = NULL;
	game->map.height = map_lines;
	game->map.width = find_max_width(game->map.grid);
	if (!validate_map(game))
		return (0);
	return (1);
}

/**
 * Parse la map à partir des lignes du fichier
 */
int	parse_map(char **lines, t_game *game, int start_index)
{
	int	map_start;
	int	map_lines;

	map_start = 0;
	map_lines = count_map_lines(lines, start_index, &map_start);
	if (map_lines == 0)
		return (0);
	if (!build_map_structure(game, lines, map_start, map_lines))
	{
		if (game->map.grid)
			free_map(game->map.grid);
		return (0);
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_map_utils2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 14:24:07 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/05 14:25:44 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
* Vérifie si une ligne est vide (ne contient que des espaces ou des tabulations)
 */
static int	is_empty_line(char *line)
{
	int	i;

	i = 0;
	while (line[i])
	{
		if (line[i] != ' ' && line[i] != '\t')
			return (0);
		i++;
	}
	return (1);
}

/**
 * Vérifie s'il y a du contenu non valide après la fin de la map
 */
static int	check_content_after_map(char **lines, int end_index)
{
	int	i;

	i = end_index;
	while (lines[i])
	{
		if (lines[i][0] != '\0' && !is_empty_line(lines[i]))
			return (0);
		i++;
	}
	return (1);
}

/**
 * Compte le nombre de lignes de la map et vérifie sa validité
 */
int	count_map_lines(char **lines, int start_index, int *map_start)
{
	int	i;
	int	found_map;
	int	in_map;
	int	map_lines;

	i = start_index;
	found_map = 0;
	in_map = 0;
	map_lines = 0;
	while (lines[i])
	{
		if (is_map_line(lines[i]) && !found_map)
		{
			found_map = 1;
			*map_start = i;
		}
		if (!handle_map_line(lines, i, &in_map, &map_lines))
			break ;
		i++;
	}
	if (!check_content_after_map(lines, i) && lines[i])
		return (exit_error("Error\nContenu invalide après la map"), 0);
	if (map_lines == 0)
		return (exit_error("Error\nAucune map trouvée"), 0);
	return (map_lines);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_map_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 18:44:42 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/05 14:25:10 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Vérifie si une ligne est une ligne de map valide
 */
int	is_map_line(char *line)
{
	int	i;
	int	found_valid_char;

	i = 0;
	found_valid_char = 0;
	while (line[i])
	{
		if (ft_strchr("01NSEWDM", line[i]))
			found_valid_char = 1;
		else if (line[i] != ' ' && line[i] != '\t')
			return (0);
		i++;
	}
	return (found_valid_char);
}

/**
 * Vérifie si une ligne vide est suivie d'une ligne de map valide
 */
int	is_map_interrupted(char **lines, int i)
{
	int	j;

	j = i + 1;
	while (lines[j])
	{
		if (is_map_line(lines[j]))
			return (1);
		j++;
	}
	return (0);
}

/**
 * Compte les lignes de la map et gestion des erreurs
 */
int	handle_map_line(char **lines, int i, int *in_map, int *map_lines)
{
	if (is_map_line(lines[i]))
	{
		*in_map = 1;
		(*map_lines)++;
		return (1);
	}
	else if (lines[i][0] == '\0')
	{
		if (*in_map && is_map_interrupted(lines, i))
			return (exit_error("Error\nLigne vide dans la map"), 0);
	}
	else
	{
		if (*in_map)
			return (0);
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_config2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 14:32:17 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/05 15:07:06 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Vérifie si une ligne est une couleur
 */
static int	is_color_line(char *line)
{
	return (ft_strncmp(line, "F ", 2) == 0 || ft_strncmp(line, "C ", 2) == 0);
}

/**
 * Détermine la phase de parsing pour une ligne
 */
static int	determine_phase(int current_phase, char *line)
{
	if (current_phase == 0 && is_color_line(line))
		return (1);
	else if (current_phase <= 1 && is_map_start(line))
		return (2);
	return (current_phase);
}

/**
 * Vérifie si l'ordre des éléments est respecté
 */
static int	check_element_order(int phase, char *line)
{
	if (phase == 1 && is_texture_line(line))
		return (exit_error("Error\nTextures erreur ordre declaration"),
			0);
	return (1);
}

/**
 * Prépare et vérifie la phase d'une ligne
 */
static int	prepare_phase(char *line, int *phase)
{
	*phase = determine_phase(*phase, line);
	if (!check_element_order(*phase, line))
		return (-1);
	if (*phase == 2)
		return (1);
	return (0);
}

/**
 * Traite une ligne de configuration avec structure de param
 */
int	handle_config(t_config_data *data, char *line)
{
	int	result;
	int	prep;

	prep = prepare_phase(line, &data->phase);
	if (prep < 0)
		return (-1);
	if (prep > 0)
		return (2);
	result = process_line(line, data->game, data->config_count, data->flags);
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_config3.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 14:32:17 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/06 11:12:29 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Initialise la structure de données de config
 */
static void	init_config_data(t_config_data *data, t_game *game,
		int *config_count, t_config_flags *flags)
{
	data->game = game;
	data->config_count = config_count;
	data->flags = flags;
	data->phase = 0;
}

/**
 * Initialise les paramètres pour le parsing
 */
static void	init_parse_params(int *i, int *config_count, t_config_flags *flags)
{
	*i = 0;
	*config_count = 0;
	ft_memset(flags, 0, sizeof(t_config_flags));
}

/**
 * Traite les résultats de la configuration
 */
static int	handle_config_result(t_config_data *data, int *map_start_index,
		int i, int result)
{
	if (result < 0)
		return (0);
	if (result == 2 || data->phase == 2)
	{
		*map_start_index = i;
		return (2);
	}
	return (1);
}

/**
 * Traite les lignes pour le parsing
 */
static int	process_config_lines(char **lines, t_game *game,
		int *map_start_index, t_config_flags *flags)
{
	int				i;
	int				config_count;
	int				result;
	t_config_data	data;

	init_parse_params(&i, &config_count, flags);
	init_config_data(&data, game, &config_count, flags);
	while (lines[i])
	{
		if (lines[i][0] != '\0')
		{
			result = handle_config(&data, lines[i]);
			result = handle_config_result(&data, map_start_index, i, result);
			if (result == 0 || result == 2)
				break ;
		}
		i++;
	}
	return (check_config_count(config_count, 6,
			"Error\nConfiguration incomplète"));
}

/**
 * Parse les configurations du fichier .cub
 */
int	parse_config(char **lines, t_game *game, int *map_start_index)
{
	t_config_flags	flags;

	return (process_config_lines(lines, game, map_start_index, &flags));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_config.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 20:07:23 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/05 15:07:02 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Traite les couleurs (F, C)
 */
static int	process_colors(char *line, t_game *game, int *config_count,
		t_config_flags *flags)
{
	if (ft_strncmp(line, "F ", 2) == 0)
	{
		if (!parse_color_config(line, &game->floor_color, &flags->f_set))
			return (0);
		(*config_count)++;
		return (1);
	}
	else if (ft_strncmp(line, "C ", 2) == 0)
	{
		if (!parse_color_config(line, &game->ceiling_color, &flags->c_set))
			return (0);
		(*config_count)++;
		return (1);
	}
	return (0);
}

/**
 * Traite les textures supplémentaires (porte)
 */
static int	process_door_texture(char *line, t_game *game, int *config_count)
{
	if (ft_strncmp(line, "DR ", 3) == 0)
	{
		game->door_tex.img = (void *)ft_strdup(line + 3);
		(*config_count)++;
		return (1);
	}
	return (0);
}

/**
 * Traite la ligne de configuration pour vérifier s'il s'agit du début de la map
 */
static int	check_map_begin(char *line, int *config_count)
{
	int	is_map;

	is_map = is_map_start(line);
	if (is_map)
	{
		if (!check_config_count(*config_count, 6,
				"Error\nConfiguration incomplète avant la map"))
			return (-1);
		return (2);
	}
	return (handle_unknown_config(is_map));
}

/**
 * Traite une ligne de configuration
 */
int	process_line(char *line, t_game *game, int *config_count,
		t_config_flags *flags)
{
	int	result;

	if (line[0] == '\0')
		return (1);
	result = process_north_south(line, game, config_count, flags);
	if (result != 0)
		return (result);
	result = process_west_east(line, game, config_count, flags);
	if (result != 0)
		return (result);
	result = process_colors(line, game, config_count, flags);
	if (result != 0)
		return (result);
	result = process_door_texture(line, game, config_count);
	if (result != 0)
		return (result);
	result = process_weapon_textures(line, game);
	if (result != 0)
		return (result);
	result = process_monster_textures(line, game);
	if (result != 0)
		return (result);
	return (check_map_begin(line, config_count));
}

/**
 * Vérifie si une ligne est une texture
 */
int	is_texture_line(char *line)
{
	return (ft_strncmp(line, "NO ", 3) == 0 || ft_strncmp(line, "SO ", 3) == 0
		|| ft_strncmp(line, "WE ", 3) == 0 || ft_strncmp(line, "EA ", 3) == 0
		|| ft_strncmp(line, "DR ", 3) == 0 || ft_strncmp(line, "MT", 2) == 0
		|| ft_strncmp(line, "WP", 2) == 0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_config_utils.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 20:51:42 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/05 14:47:33 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Traite les textures principales (NO, SO)
 */
int	process_north_south(char *line, t_game *game, int *config_count,
		t_config_flags *flags)
{
	if (ft_strncmp(line, "NO ", 3) == 0)
	{
		if (!parse_texture_line(line, &game->north_tex.img, &flags->no_set))
			return (0);
		(*config_count)++;
		return (1);
	}
	else if (ft_strncmp(line, "SO ", 3) == 0)
	{
		if (!parse_texture_line(line, &game->south_tex.img, &flags->so_set))
			return (0);
		(*config_count)++;
		return (1);
	}
	return (0);
}

/**
 * Traite les textures principales (WE, EA)
 */
int	process_west_east(char *line, t_game *game, int *config_count,
		t_config_flags *flags)
{
	if (ft_strncmp(line, "WE ", 3) == 0)
	{
		if (!parse_texture_line(line, &game->west_tex.img, &flags->we_set))
			return (0);
		(*config_count)++;
		return (1);
	}
	else if (ft_strncmp(line, "EA ", 3) == 0)
	{
		if (!parse_texture_line(line, &game->east_tex.img, &flags->ea_set))
			return (0);
		(*config_count)++;
		return (1);
	}
	return (0);
}

/**
 * Traite les textures d'armes
 */
int	process_weapon_textures(char *line, t_game *game)
{
	if (ft_strncmp(line, "WP0 ", 4) == 0)
		return (parse_weapon_frame(game, line, 0));
	else if (ft_strncmp(line, "WP1 ", 4) == 0)
		return (parse_weapon_frame(game, line, 1));
	else if (ft_strncmp(line, "WP2 ", 4) == 0)
		return (parse_weapon_frame(game, line, 2));
	else if (ft_strncmp(line, "WP3 ", 4) == 0)
		return (parse_weapon_frame(game, line, 3));
	return (0);
}

/**
 * Traite les textures de monstres
 */
int	process_monster_textures(char *line, t_game *game)
{
	if (ft_strncmp(line, "MT0 ", 4) == 0)
		return (parse_monster_frame(game, line, 0));
	else if (ft_strncmp(line, "MT1 ", 4) == 0)
		return (parse_monster_frame(game, line, 1));
	else if (ft_strncmp(line, "MT2 ", 4) == 0)
		return (parse_monster_frame(game, line, 2));
	else if (ft_strncmp(line, "MT3 ", 4) == 0)
		return (parse_monster_frame(game, line, 3));
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_cub_file2.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/06 11:25:24 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/06 11:26:34 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

int	get_num(char *str)
{
	int	num;
	int	i;

	i = 0;
	num = 0;
	while (str[i] && (str[i] == ' ' || str[i] == '\t'))
		i++;
	while (str[i] && str[i] >= '0' && str[i] <= '9')
	{
		num = num * 10 + (str[i] - '0');
		i++;
	}
	while (str[i])
	{
		if (str[i] != ' ' && str[i] != '\t')
			return (-1);
		i++;
	}
	return (num);
}

int	count_char(char *str, char c)
{
	int	count;
	int	i;

	count = 0;
	i = 0;
	while (str[i])
	{
		if (str[i] == c)
			count++;
		i++;
	}
	return (count);
}

int	parse_color_line(char *line)
{
	char	**parts;
	int		color;
	int		r;
	int		g;
	int		b;

	if (count_char(line, ',') != 2)
		return (exit_error("Error\nFormat RGB invalide"), -1);
	parts = ft_split(line, ',');
	if (!parts || !parts[0] || !parts[1] || !parts[2] || parts[3])
		return (free_split(parts), exit_error("Error\nCouleur invalide"), -1);
	r = get_num(parts[0]);
	g = get_num(parts[1]);
	b = get_num(parts[2]);
	free_split(parts);
	if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255)
		return (exit_error("Error\nValeurs RGB hors limites"), -1);
	color = (r << 16) | (g << 8) | b;
	return (color);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_cub_file.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/28 14:39:22 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/06 11:43:06 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Lit le contenu d'un fichier et le découpe en lignes
 */
char	**read_files_lines(const char *filename)
{
	int		fd;
	char	**lines;
	int		count;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return (NULL);
	count = count_file_lines(fd);
	if (count <= 0)
		return (NULL);
	close(fd);
	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return (NULL);
	lines = allocate_lines(fd, count);
	close(fd);
	return (lines);
}

/**
 * Libère la mémoire d'un tableau de chaînes
 */
void	free_split(char **split)
{
	int	i;

	i = 0;
	if (!split)
		return ;
	while (split[i])
	{
		free(split[i]);
		i++;
	}
	free(split);
}

/**
 * Parse le fichier .cub complet (configuration et map)
 */
int	parse_cub_file(const char *filename, t_game *game)
{
	char	**lines;
	int		map_start_index;

	lines = read_files_lines(filename);
	if (!lines)
		return (exit_error("Error: Could not read .cub file"), 0);
	map_start_index = 0;
	if (!parse_config(lines, game, &map_start_index))
	{
		cleanup_config_resources(game);
		free_split(lines);
		return (0);
	}
	if (!parse_map(lines, game, map_start_index))
	{
		cleanup_config_resources(game);
		free_split(lines);
		return (0);
	}
	free_split(lines);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_cub_utils2.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 20:05:22 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/05 14:48:07 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Parse une ligne de configuration pour une frame d'arme
 */
int	parse_weapon_frame(t_game *game, char *line, int index)
{
	if (game->weapon_paths[index] != NULL)
		return (exit_error("Error\nDuplication texture d'arme"), 0);
	game->weapon_paths[index] = ft_strdup(line + 4);
	if (game->weapon_frame_count < index + 1)
		game->weapon_frame_count = index + 1;
	return (1);
}

/**
 * Parse une ligne de configuration pour une frame de monstre
 */
int	parse_monster_frame(t_game *game, char *line, int index)
{
	if (game->monster_paths[index] != NULL)
		return (exit_error("Error\nDuplication texture de monstre"), 0);
	game->monster_paths[index] = ft_strdup(line + 4);
	if (game->monster_frame_count < index + 1)
		game->monster_frame_count = index + 1;
	return (1);
}

/**
 * Vérifie si une ligne est le début de la map
 */
int	is_map_start(char *line)
{
	int	j;

	j = 0;
	while (line[j] && (line[j] == ' ' || line[j] == '\t'))
		j++;
	if (ft_strncmp(line + j, "NO ", 3) == 0 || ft_strncmp(line + j, "SO ",
			3) == 0 || ft_strncmp(line + j, "WE ", 3) == 0 || ft_strncmp(line
			+ j, "EA ", 3) == 0 || ft_strncmp(line + j, "F ", 2) == 0
		|| ft_strncmp(line + j, "C ", 2) == 0 || ft_strncmp(line + j, "DR ",
			3) == 0 || ft_strncmp(line + j, "MT", 2) == 0 || ft_strncmp(line
			+ j, "WP", 2) == 0)
		return (0);
	if (line[j] && ft_strchr("01NSEWDM", line[j]))
		return (1);
	return (0);
}

/**
 * Vérifie si le nombre d'éléments de configuration est suffisant
 */
int	check_config_count(int config_count, int min_required, char *error_msg)
{
	if (config_count < min_required)
		return (exit_error(error_msg), 0);
	return (1);
}

/**
 * Traite les erreurs de ligne de configuration inconnue
 */
int	handle_unknown_config(int is_map_start_flag)
{
	if (is_map_start_flag)
		return (1);
	return (exit_error("Error\nLigne de config inconnue"), -1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_cub_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 20:01:16 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/06 11:43:11 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Compte le nombre de lignes dans un fichier
 */
int	count_file_lines(int fd)
{
	char	*line;
	int		count;

	count = 0;
	line = NULL;
	while (1)
	{
		line = get_next_line(fd);
		if (!line)
			break ;
		count++;
		free(line);
	}
	return (count);
}

/**
 * Alloue et remplit le tableau de lignes à partir du fichier
 */
char	**allocate_lines(int fd, int count)
{
	char	**lines;
	char	*line;
	int		i;
	int		len;

	lines = malloc(sizeof(char *) * (count + 1));
	if (!lines)
		return (NULL);
	i = 0;
	while (i < count)
	{
		line = get_next_line(fd);
		if (!line)
			break ;
		len = ft_strlen(line);
		if (len > 0 && line[len - 1] == '\n')
			line[len - 1] = '\0';
		lines[i] = line;
		i++;
	}
	lines[i] = NULL;
	return (lines);
}

/**
 * Vérifie si une texture est déjà définie
 */
int	check_texture_duplication(int is_set, char *texture_type)
{
	if (is_set)
	{
		exit_error("Error\nDuplication texture ");
		ft_printf("%s\n", texture_type);
		return (0);
	}
	return (1);
}

/**
 * Parse une ligne de configuration pour une texture
 */
int	parse_texture_line(char *line, void **texture_img, int *is_set)
{
	char	*texture_path;

	if (!check_texture_duplication(*is_set, line))
		return (0);
	texture_path = ft_strdup(line + 3);
	if (!texture_path)
		return (exit_error("Error\nMémoire insuffisante"), 0);
	*texture_img = (void *)texture_path;
	*is_set = 1;
	return (1);
}

/**
 * Parse une ligne de configuration pour une couleur
 */
int	parse_color_config(char *line, int *color_ptr, int *is_set)
{
	if (!check_texture_duplication(*is_set, line))
		return (0);
	*color_ptr = parse_color_line(line + 2);
	if (*color_ptr == -1)
		return (0);
	*is_set = 1;
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validate_map.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/31 13:12:10 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/05/02 18:54:43 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Vérifie si la map est fermée
 */
int	is_map_closed(char **map, int width, int height)
{
	char	c;
	int		x;
	int		y;

	(void)width;
	y = 0;
	while (y < height)
	{
		x = 0;
		while (map[y][x])
		{
			c = map[y][x];
			if (c == '0' || ft_strchr("PNSEWM", c))
			{
				if (!is_cell_enclosed(map, y, x, height))
					return (0);
			}
			x++;
		}
		y++;
	}
	return (1);
}

/**
 * Initialise la position et l'orientation du joueur
 */
void	init_player(t_game *game, int x, int y, char dir)
{
	if (dir == 'N')
		init_player_north(game, x, y);
	else if (dir == 'S')
		init_player_south(game, x, y);
	else if (dir == 'E')
		init_player_east(game, x, y);
	else if (dir == 'W')
		init_player_west(game, x, y);
}

/**
 * Parcourt la map pour vérifier les caractères valides
 */
static int	check_map_characters(t_game *game, int *player_count)
{
	char		**map;
	int			y;
	int			x;
	t_map_check	check;

	map = game->map.grid;
	*player_count = 0;
	y = 0;
	while (map[y])
	{
		x = 0;
		while (map[y][x])
		{
			check.x = x;
			check.y = y;
			check.count = player_count;
			if (!process_map_char(game, map[y][x], &check))
				return (0);
			x++;
		}
		y++;
	}
	return (1);
}

/**
 * Valide la map en vérifiant caractères, joueur et fermeture
 */
int	validate_map(t_game *game)
{
	int	player_count;

	if (!check_map_characters(game, &player_count))
		return (0);
	if (player_count != 1)
		return (exit_error("Error\nAucun joueur trouvé"), 0);
	if (!is_map_closed(game->map.grid, game->map.width, game->map.height))
		return (exit_error("Error\nMap non fermée"), 0);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validate_map_utils2.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 18:32:14 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/02 18:53:04 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Initialise la direction du joueur (N)
 */
void	init_player_north(t_game *game, int x, int y)
{
	game->player.x = x + 0.5;
	game->player.y = y + 0.5;
	game->player.dir_x = 0;
	game->player.dir_y = -1;
	game->player.plane_x = 0.66;
	game->player.plane_y = 0;
}

/**
 * Initialise la direction du joueur (S)
 */
void	init_player_south(t_game *game, int x, int y)
{
	game->player.x = x + 0.5;
	game->player.y = y + 0.5;
	game->player.dir_x = 0;
	game->player.dir_y = 1;
	game->player.plane_x = -0.66;
	game->player.plane_y = 0;
}

/**
 * Initialise la direction du joueur (E)
 */
void	init_player_east(t_game *game, int x, int y)
{
	game->player.x = x + 0.5;
	game->player.y = y + 0.5;
	game->player.dir_x = 1;
	game->player.dir_y = 0;
	game->player.plane_x = 0;
	game->player.plane_y = 0.66;
}

/**
 * Initialise la direction du joueur (W)
 */
void	init_player_west(t_game *game, int x, int y)
{
	game->player.x = x + 0.5;
	game->player.y = y + 0.5;
	game->player.dir_x = -1;
	game->player.dir_y = 0;
	game->player.plane_x = 0;
	game->player.plane_y = -0.66;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validate_map_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 18:31:14 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/02 18:55:22 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Vérifie les limites horizontales d'une case
 */
int	check_horizontal_bounds(char **map, int y, int x)
{
	int	start;
	int	end;
	int	line_len;

	line_len = ft_strlen(map[y]);
	start = 0;
	end = line_len - 1;
	while (map[y][start] == ' ')
		start++;
	while (end > 0 && map[y][end] == ' ')
		end--;
	if (x == start || x == end)
		return (0);
	if (x > 0 && map[y][x - 1] == ' ')
		return (0);
	if (x < line_len - 1 && map[y][x + 1] == ' ')
		return (0);
	return (1);
}

/**
 * Vérifie les limites verticales d'une case
 */
int	check_vertical_bounds(char **map, int y, int x)
{
	if (y == 0)
		return (0);
	if (x >= (int)ft_strlen(map[y - 1]) || map[y - 1][x] == ' ')
		return (0);
	if (y + 1 < 0 || !map[y + 1])
		return (0);
	if (x >= (int)ft_strlen(map[y + 1]) || map[y + 1][x] == ' ')
		return (0);
	return (1);
}

/**
 * Vérifie si une case est entourée par des murs ou des cases valides
 */
int	is_cell_enclosed(char **map, int y, int x, int height)
{
	if (y == 0 || y == height - 1)
		return (0);
	if (!check_horizontal_bounds(map, y, x))
		return (0);
	if (!check_vertical_bounds(map, y, x))
		return (0);
	return (1);
}

/**
 * Traite un caractère de la map
 */
int	process_map_char(t_game *game, char c, t_map_check *check)
{
	if (!ft_strchr("01PNSEWMD ", c))
		return (exit_error("Error\nCaractère invalide dans la map"), 0);
	if (ft_strchr("NSEW", c))
	{
		if ((*(check->count))++)
			return (exit_error("Error\nPlus d'un joueur trouvé"), 0);
		init_player(game, check->x, check->y, c);
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycasting2.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 20:15:00 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/01 09:22:27 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Exécute l'algorithme DDA pour trouver le mur touché
 * 
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 */
void	perform_dda(t_ray *ray, t_game *game)
{
	while (ray->hit == 0)
	{
		if (ray->side_dist_x < ray->side_dist_y)
		{
			ray->side_dist_x += ray->delta_dist_x;
			ray->map_x += ray->step_x;
			ray->side = 0;
		}
		else
		{
			ray->side_dist_y += ray->delta_dist_y;
			ray->map_y += ray->step_y;
			ray->side = 1;
		}
		if (is_ray_hit(ray, game))
			ray->hit = 1;
	}
}

/**
 * Calcule la hauteur de la ligne à dessiner à l'écran
 * 
 * @param ray Structure contenant les informations du rayon
 */
void	calculate_line_height(t_ray *ray)
{
	if (ray->side == 0)
		ray->perp_wall_dist = (ray->side_dist_x - ray->delta_dist_x);
	else
		ray->perp_wall_dist = (ray->side_dist_y - ray->delta_dist_y);
	ray->line_height = (int)(WIN_HEIGHT / ray->perp_wall_dist);
	ray->draw_start = -ray->line_height / 2 + WIN_HEIGHT / 2;
	if (ray->draw_start < 0)
		ray->draw_start = 0;
	ray->draw_end = ray->line_height / 2 + WIN_HEIGHT / 2;
	if (ray->draw_end >= WIN_HEIGHT)
		ray->draw_end = WIN_HEIGHT - 1;
}

/**
 * Fonction principale de raycasting pour toute la largeur de l'écran
 * 
 * @param game Structure principale du jeu
 */
void	raycasting(t_game *game)
{
	t_ray	ray;
	int		x;

	x = 0;
	while (x < WIN_WIDTH)
	{
		ft_memset(&ray, 0, sizeof(t_ray));
		init_ray(&ray, game, x);
		calculate_step_and_side_dist(&ray);
		perform_dda(&ray, game);
		calculate_line_height(&ray);
		draw_textured_line(x, &ray, game);
		x++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycasting.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/01 14:08:46 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/01 09:25:13 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Initialise les paramètres du rayon pour un x donné de l'écran
 * 
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 * @param x Coordonnée X sur l'écran
 */
void	init_ray(t_ray *ray, t_game *game, int x)
{
	double	camera_x;

	camera_x = 2 * x / (double)WIN_WIDTH - 1;
	ray->dir_x = game->player.dir_x + game->player.plane_x * camera_x;
	ray->dir_y = game->player.dir_y + game->player.plane_y * camera_x;
	ray->pos_x = game->player.x;
	ray->pos_y = game->player.y;
	ray->map_x = (int)ray->pos_x;
	ray->map_y = (int)ray->pos_y;
	if (fabs(ray->dir_x) < 1e-10)
		ray->delta_dist_x = 1e30;
	else
		ray->delta_dist_x = fabs(1 / ray->dir_x);
	if (fabs(ray->dir_y) < 1e-10)
		ray->delta_dist_y = 1e30;
	else
		ray->delta_dist_y = fabs(1 / ray->dir_y);
	ray->hit = 0;
	ray->hit_type = 0;
}

/**
 * Calcule la direction du pas et la distance jusqu'à la prochaine intersection
 * 
 * @param ray Structure contenant les informations du rayon
 */
void	calculate_step_and_side_dist(t_ray *ray)
{
	if (ray->dir_x < 0)
	{
		ray->step_x = -1;
		ray->side_dist_x = (ray->pos_x - ray->map_x) * ray->delta_dist_x;
	}
	else
	{
		ray->step_x = 1;
		ray->side_dist_x = (ray->map_x + 1.0 - ray->pos_x) * ray->delta_dist_x;
	}
	if (ray->dir_y < 0)
	{
		ray->step_y = -1;
		ray->side_dist_y = (ray->pos_y - ray->map_y) * ray->delta_dist_y;
	}
	else
	{
		ray->step_y = 1;
		ray->side_dist_y = (ray->map_y + 1.0 - ray->pos_y) * ray->delta_dist_y;
	}
}

/**
 * Vérifie si une position dans la map est valide
 * 
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 * @return 1 si la position est valide, 0 sinon
 */
static int	is_valid_ray_position(t_ray *ray, t_game *game)
{
	if (ray->map_y < 0 || ray->map_y >= game->map.height || ray->map_x < 0)
		return (0);
	if (ray->map_x >= (int)ft_strlen(game->map.grid[ray->map_y]))
		return (0);
	return (1);
}

/**
 * Configure le type de hit pour les portes
 * 
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 */
static void	set_door_hit_type(t_ray *ray, t_game *game)
{
	ray->hit = 1;
	if (game->door_opened)
		ray->hit_type = 3;
	else
		ray->hit_type = 2;
}

/**
 * Vérifie si le rayon a touché un mur ou une porte
 * 
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 * @return 1 si le rayon a touché quelque chose, 0 sinon
 */
int	is_ray_hit(t_ray *ray, t_game *game)
{
	char	cell;

	if (!is_valid_ray_position(ray, game))
		return (1);
	cell = game->map.grid[ray->map_y][ray->map_x];
	if (cell == '1' || cell == ' ')
		return (1);
	if (cell == 'D')
	{
		set_door_hit_type(ray, game);
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycasting_utils2.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 20:18:00 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/01 09:20:32 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Détermine la couleur du mur en fonction de la direction
 * 
 * @param ray Structure contenant les informations du rayon
 * @return Couleur du mur
 */
static int	get_wall_color(t_ray *ray)
{
	int	color;

	color = 0;
	if (ray->side == 0)
	{
		if (ray->dir_x > 0)
			color = 0xFF0000;
		else
			color = 0x00FF00;
	}
	else
	{
		if (ray->dir_y > 0)
			color = 0x0000FF;
		else
			color = 0xFFFF00;
	}
	return (color);
}

/**
 * Dessine un pixel de la colonne si il est dans les limites de l'écran
 * 
 * @param game Structure principale du jeu
 * @param x Coordonnée X
 * @param y Coordonnée Y
 * @param color Couleur du pixel
 */
static void	draw_pixel_if_valid(t_game *game, int x, int y, int color)
{
	if (y >= 0 && y < WIN_HEIGHT && x >= 0 && x < WIN_WIDTH)
		game->img_data[y * (game->size_line / 4) + x] = color;
}

/**
 * Version de test qui dessine des lignes colorées sans textures
 *
 * @param x Coordonnée X de la colonne à dessiner
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 */
void	safe_draw_textured_line(int x, t_ray *ray, t_game *game)
{
	int	color;
	int	y;

	color = get_wall_color(ray);
	if (ray->side == 1)
		color = (color >> 1) & 0x7F7F7F;
	y = ray->draw_start;
	while (y < ray->draw_end)
	{
		draw_pixel_if_valid(game, x, y, color);
		y++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycasting_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/25 14:00:00 by jmaizel           #+#    #+#             */
/*   Updated: 2025/05/01 09:21:15 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/**
 * Vérifie si le rayon a touché une limite ou un mur
 * 
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 * @return 1 si le rayon a touché, 0 sinon
 */
static int	check_ray_hit_wall(t_ray *ray, t_game *game)
{
	if (ray->map_y < 0 || ray->map_y >= game->map.height || ray->map_x < 0)
		return (1);
	else if (ray->map_x >= (int)ft_strlen(game->map.grid[ray->map_y]))
		return (1);
	else if (game->map.grid[ray->map_y][ray->map_x] == '1')
		return (1);
	return (0);
}

/**
 * Vérifie si le rayon a touché une porte
 * 
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 * @return 1 si le rayon a touché une porte, 0 sinon
 */
static int	check_ray_hit_door(t_ray *ray, t_game *game)
{
	if (game->map.grid[ray->map_y][ray->map_x] == 'D')
	{
		ray->hit = 1;
		if (game->door_opened)
			ray->hit_type = 3;
		else
			ray->hit_type = 2;
		return (1);
	}
	return (0);
}

/**
 * Avance le rayon d'un pas selon l'algorithme DDA
 * 
 * @param ray Structure contenant les informations du rayon
 */
static void	advance_ray(t_ray *ray)
{
	if (ray->side_dist_x < ray->side_dist_y)
	{
		ray->side_dist_x += ray->delta_dist_x;
		ray->map_x += ray->step_x;
		ray->side = 0;
	}
	else
	{
		ray->side_dist_y += ray->delta_dist_y;
		ray->map_y += ray->step_y;
		ray->side = 1;
	}
}

/**
 * Version sécurisée du DDA avec gestion des portes
 *
 * @param ray Structure contenant les informations du rayon
 * @param game Structure principale du jeu
 */
void	safe_perform_dda(t_ray *ray, t_game *game)
{
	int	max_iterations;
	int	iterations;

	max_iterations = 100;
	iterations = 0;
	while (ray->hit == 0 && iterations < max_iterations)
	{
		advance_ray(ray);
		if (check_ray_hit_wall(ray, game))
			ray->hit = 1;
		else if (check_ray_hit_door(ray, game))
			ray->hit = 1;
		iterations++;
	}
}

/**
 * Lance un rayon pour chaque colonne de l'écran
 *
 * @param game Structure principale du jeu
 */
void	complete_raycasting(t_game *game)
{
	t_ray	ray;
	int		x;

	x = 0;
	while (x < WIN_WIDTH)
	{
		ft_memset(&ray, 0, sizeof(t_ray));
		init_ray(&ray, game, x);
		calculate_step_and_side_dist(&ray);
		safe_perform_dda(&ray, game);
		calculate_line_height(&ray);
		game->z_buffer[x] = ray.perp_wall_dist;
		draw_textured_line(x, &ray, game);
		x++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cub3d.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 22:10:27 by cdedessu          #+#    #+#             */
/*   Updated: 2025/05/06 11:43:33 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CUB3D_H
# define CUB3D_H

# include "../libft/includes/ft_printf.h"
# include "../libft/includes/get_next_line.h"
# include "../libft/includes/libft.h"
# include "../minilibx-linux/mlx.h"
# include <fcntl.h>
# include <math.h>
# include <stdio.h>
# include <stdlib.h>
# include <sys/time.h>
# include <unistd.h>

/*
** Window dimensions
*/
# define WIN_WIDTH 1024
# define WIN_HEIGHT 720

/*
** Texture dimensions
*/
# define TEX_WIDTH 64
# define TEX_HEIGHT 64

/*
** Game constants
*/
# define MAX_MONSTERS 20
# define M_PI 3.14159265358979323846
# define ROT_SPEED 0.05
# define MOVE_SPEED 0.1

/*
** Minimap colors
*/
# define MAP_BG_COLOR 0x222222
# define MAP_WALL_COLOR 0xE0E0E0
# define MAP_FLOOR_COLOR 0x303030
# define MAP_PLAYER_COLOR 0xFF2020
# define MAP_BORDER_COLOR 0x404040

/*
** Basic structures
*/
typedef struct s_player
{
	double			x;
	double			y;
	double			dir_x;
	double			dir_y;
	double			plane_x;
	double			plane_y;
}					t_player;

typedef struct s_map
{
	char			**grid;
	int				width;
	int				height;
}					t_map;

typedef struct s_texture
{
	void			*img;
	int				*data;
	int				width;
	int				height;
	int				bpp;
	int				size_line;
	int				endian;
}					t_texture;

typedef struct s_monster
{
	double			x;
	double			y;
	int				alive;
	int				frame;
	double			anim_time;
	double			anim_speed;
	int				health;
	int				max_health;
	int				hit_animation;
	double			hit_timer;
}					t_monster;

/*
** Ray-casting structures
*/
typedef struct s_ray
{
	double			pos_x;
	double			pos_y;
	double			dir_x;
	double			dir_y;
	double			delta_dist_x;
	double			delta_dist_y;
	double			side_dist_x;
	double			side_dist_y;
	double			perp_wall_dist;
	int				map_x;
	int				map_y;
	int				step_x;
	int				step_y;
	int				hit;
	int				side;
	int				line_height;
	int				draw_start;
	int				draw_end;
	int				hit_type;
}					t_ray;

/*
** Drawing structures
*/
typedef struct s_sprite
{
	double			x;
	double			y;
	int				width;
	int				height;
	int				screen_x;
	double			transform_y;
}					t_sprite;

typedef struct s_draw_params
{
	int				stripe;
	int				y;
	t_sprite		*sprite;
	int				tex_x;
	int				draw_start_y;
	int				draw_end_y;
}					t_draw_params;

typedef struct s_draw_limits
{
	int				draw_start_x;
	int				draw_end_x;
	int				draw_start_y;
	int				draw_end_y;
}					t_draw_limits;

typedef struct s_minimap_size
{
	int				width;
	int				height;
}					t_minimap_size;

typedef struct s_minimap_pos
{
	int				x;
	int				y;
	int				cell_size;
}					t_minimap_pos;

typedef struct s_line
{
	int				x0;
	int				y0;
	int				x1;
	int				y1;
}					t_line;

typedef struct s_point_dir
{
	int				x;
	int				y;
	int				dir_x;
	int				dir_y;
}					t_point_dir;

typedef struct s_weapon_pos
{
	int				x;
	int				y;
	int				width;
	int				height;
}					t_weapon_pos;

typedef struct s_weapon_draw
{
	int				start_x;
	int				start_y;
	int				x;
	int				y;
	int				draw_x;
	int				draw_y;
	int				color;
}					t_weapon_draw;

typedef struct s_tex_params
{
	int				tex_x;
	double			tex_pos;
	double			step;
}					t_tex_params;

/*
** Configuration structures
*/
typedef struct s_config_flags
{
	int				no_set;
	int				so_set;
	int				we_set;
	int				ea_set;
	int				f_set;
	int				c_set;
}					t_config_flags;

typedef struct s_map_check
{
	int				x;
	int				y;
	int				*count;
}					t_map_check;

/*
** Main game structure
*/

typedef struct s_game
{
	void			*mlx;
	void			*win;
	t_map			map;
	t_player		player;

	t_texture		north_tex;
	t_texture		south_tex;
	t_texture		east_tex;
	t_texture		west_tex;

	t_texture		monster_frames[4];
	int				monster_frame_count;
	char			*monster_paths[4];

	int				ceiling_color;
	int				floor_color;
	int				keys[256];
	int				rotate_left;
	int				rotate_right;
	double			move_speed;
	double			rot_speed;

	double			last_frame_time;
	double			delta_time;

	int				door_opened;
	int				all_monsters_killed;
	int				victory_displayed;
	double			victory_timer;
	int				victory_final;
	t_texture		door_tex;

	t_texture		weapon_tex;
	char			*weapon_paths[4];

	t_monster		monsters[MAX_MONSTERS];
	int				monster_count;
	double			z_buffer[WIN_WIDTH];

	void			*img;
	int				*img_data;
	int				bpp;
	int				size_line;
	int				endian;

	int				mouse_x;
	int				mouse_prev_x;
	int				mouse_enabled;
	double			mouse_sensitivity;

	int				firing;
	double			weapon_cooldown;
	double			weapon_timer;
	int				weapon_damage;
	double			weapon_range;
	t_texture		weapon_frames[4];
	int				weapon_frame_count;
	int				current_weapon_frame;
	int				weapon_animating;
	double			weapon_anim_time;
	double			weapon_anim_speed;

	t_texture		victory_tex;
}					t_game;

typedef struct s_config_data
{
	t_game			*game;
	int				*config_count;
	t_config_flags	*flags;
	int				phase;
}					t_config_data;

/*
** Movement functions
*/
int					is_valid_position(t_game *game, double x, double y);
void				move_forward(t_game *game);
void				move_backward(t_game *game);
void				move_left(t_game *game);
void				move_right(t_game *game);
void				rotate_left(t_game *game);
void				rotate_right(t_game *game);
void				handle_movement(t_game *game);

/*
** Input handling
*/
int					key_press(int keycode, t_game *game);
int					key_release(int keycode, t_game *game);
int					mouse_move(int x, int y, t_game *game);
void				toggle_mouse(t_game *game);
int					mouse_click(int button, int x, int y, t_game *game);

/*
** Game loop and timing
*/
int					game_loop(t_game *game);
double				get_time(void);
void				calculate_delta_time(t_game *game);
void				update_weapon_timer(t_game *game);

/*
** Monster functions
*/
void				init_monsters(t_game *game);
void				update_monster_hit_effects(t_game *game);
void				update_monster_animations(t_game *game);
int					all_monsters_dead(t_game *game);
void				process_monster_sprite(t_game *game, t_sprite *sprite,
						int monster_idx);
void				render_monsters(t_game *game);

/*
** Combat functions
*/
void				attack(t_game *game);
void				normalize_angle(double *angle);
void				init_weapon_animation(t_game *game);
int					is_monster_in_fov(t_game *game, double dx, double dy);
void				damage_monster(t_game *game, int monster_index);

/*
** Game status management
*/
void				check_monsters_status(t_game *game);
int					check_door_victory(t_game *game);
int					find_door_position(t_game *game, int *door_x, int *door_y);
int					display_victory(t_game *game);
void				update_victory_timer(t_game *game);

/*
** Drawing functions
*/
void				draw_controls_menu(t_game *game);
void				draw_minimap(t_game *game);
void				draw_line(t_game *game, t_line line, int color);
void				draw_cell(t_game *game, t_minimap_pos pos, int color);
void				draw_player_dot(t_game *game, int x, int y, int color);
void				draw_minimap_border(t_game *game, t_minimap_pos pos,
						t_minimap_size size);
void				draw_minimap_background(t_game *game, t_minimap_pos pos,
						t_minimap_size size);
void				draw_weapon(t_game *game);
void				render_frame(t_game *game);
void				draw_victory_message(t_game *game);

/*
** Texture handling
*/
void				get_texture(t_ray *ray, t_game *game, t_texture **tex);
void				calculate_texture_x(t_ray *ray, double *wall_x, int *tex_x,
						t_texture *tex);
int					load_texture(t_game *game, t_texture *texture, char *path);
int					load_all_textures(t_game *game);
void				draw_textured_line(int x, t_ray *ray, t_game *game);
int					apply_side_shading(int color);
int					change_door_color(int color);
void				free_texture_paths(t_game *game);
void				prepare_texture_params(t_ray *ray, t_texture *tex,
						t_tex_params *params);

/*
** Enemy drawing functions
*/
void				sort_monsters(t_game *game, double *distances, int *order);
int					get_monster_pixel(t_game *game, t_draw_params params,
						int monster_idx);
void				draw_monster_pixel(t_game *game, t_draw_params params,
						int color, int monster_idx);
void				draw_monster_column(t_game *game, t_draw_params draw,
						int monster_idx);
t_sprite			calc_sprite_pos(t_game *game, int *order, int i,
						t_sprite *sprite);
void				calc_sprite_draw_limits(t_sprite *sprite,
						t_draw_limits *limits);

/*
** Utils
*/
void				free_map(char **map);
int					exit_error(char *msg);
int					close_window(t_game *game);
void				cleanup_config_resources(t_game *game);

/*
** Raycasting
*/
void				init_ray(t_ray *ray, t_game *game, int x);
void				calculate_step_and_side_dist(t_ray *ray);
int					is_ray_hit(t_ray *ray, t_game *game);
void				perform_dda(t_ray *ray, t_game *game);
void				calculate_line_height(t_ray *ray);
void				raycasting(t_game *game);
void				safe_perform_dda(t_ray *ray, t_game *game);
void				complete_raycasting(t_game *game);
void				safe_draw_textured_line(int x, t_ray *ray, t_game *game);

/*
** Parsing
*/
char				**read_files_lines(const char *filename);
void				free_split(char **split);
int					parse_color_line(char *line);
int					parse_cub_file(const char *filename, t_game *game);
int					count_file_lines(int fd);
char				**allocate_lines(int fd, int count);
int					check_texture_duplication(int is_set, char *texture_type);
int					parse_texture_line(char *line, void **texture_img,
						int *is_set);
int					parse_color_config(char *line, int *color_ptr, int *is_set);
int					parse_weapon_frame(t_game *game, char *line, int index);
int					parse_monster_frame(t_game *game, char *line, int index);
int					is_map_start(char *line);
int					check_config_count(int config_count, int min_required,
						char *error_msg);
int					handle_unknown_config(int is_map_start_flag);
int					process_north_south(char *line, t_game *game,
						int *config_count, t_config_flags *flags);
int					process_west_east(char *line, t_game *game,
						int *config_count, t_config_flags *flags);
int					process_weapon_textures(char *line, t_game *game);
int					process_monster_textures(char *line, t_game *game);
int					parse_config(char **lines, t_game *game,
						int *map_start_index);
int					find_max_width(char **map_lines);
int					parse_map(char **lines, t_game *game, int start_index);
int					is_map_line(char *line);
int					is_map_interrupted(char **lines, int i);
int					handle_map_line(char **lines, int i, int *in_map,
						int *map_lines);
int					count_map_lines(char **lines, int start_index,
						int *map_start);
int					process_line(char *line, t_game *game, int *config_count,
						t_config_flags *flags);
int					is_texture_line(char *line);
int					handle_config(t_config_data *data, char *line);

/*
** Map validation
*/
int					is_map_closed(char **map, int width, int height);
void				init_player(t_game *game, int x, int y, char dir);
int					validate_map(t_game *game);
int					check_horizontal_bounds(char **map, int y, int x);
int					check_vertical_bounds(char **map, int y, int x);
int					is_cell_enclosed(char **map, int y, int x, int height);
int					process_map_char(t_game *game, char c, t_map_check *check);
void				init_player_north(t_game *game, int x, int y);
void				init_player_south(t_game *game, int x, int y);
void				init_player_east(t_game *game, int x, int y);
void				init_player_west(t_game *game, int x, int y);

#endif# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/03/28 14:37:22 by jmaizel           #+#    #+#              #
#    Updated: 2025/05/06 11:43:39 by jmaizel          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

NAME = cub3D
CC = gcc
CFLAGS = -Wall -Wextra -Werror -I$(INCLUDES_DIR) -I$(LIBFT_DIR) -I$(MLX_DIR)

LIBFT_DIR = ./libft
MLX_DIR = ./minilibx-linux
INCLUDES_DIR = includes
OBJ_DIR = objs

MAIN_DIR = ./srcs/main
PARSING_DIR = ./srcs/parsing
RAYCASTING_DIR = ./srcs/raycasting
GAME_DIR = ./srcs/game
GRAPHICS_DIR = ./srcs/graphics

LIBS = -L$(MLX_DIR) -lmlx -lXext -lX11 -lm -L$(LIBFT_DIR) -lft
LIBFT = $(LIBFT_DIR)/libft.a
MLX = $(MLX_DIR)/libmlx.a

MAIN_FILES = main.c utils.c cleanup.c
PARSING_FILES = parse_map.c parsing_cub_file.c validate_map.c parse_map_utils.c validate_map_utils.c validate_map_utils2.c parsing_cub_utils.c parsing_cub_utils2.c parsing_config.c parsing_config_utils.c parse_map_utils2.c parsing_config2.c parsing_config3.c parsing_cub_file2.c
RAYCASTING_FILES = raycasting.c raycasting_utils.c raycasting_utils2.c raycasting2.c
GAME_FILES = movement.c mouse.c game_status_utils.c movement_utils.c attack.c attack_utils.c movement_rotate.c keyboard.c game_loop.c monster_utils.c
GRAPHICS_FILES = draw_minimap.c draw_weapon.c render_frame.c textures.c draw_enemies.c draw_menu.c draw_enemies_utils.c draw_minimap_utils.c textures_utils.c draw_enemies2.c draw_enemies_utils2.c draw_minimap_utils2.c textures2.c textures_utils2.c

SRC_FILES = $(addprefix $(MAIN_DIR)/, $(MAIN_FILES)) \
            $(addprefix $(PARSING_DIR)/, $(PARSING_FILES)) \
            $(addprefix $(RAYCASTING_DIR)/, $(RAYCASTING_FILES)) \
            $(addprefix $(GRAPHICS_DIR)/, $(GRAPHICS_FILES)) \
			$(addprefix $(GAME_DIR)/, $(GAME_FILES))

OBJS = $(SRC_FILES:./srcs/%.c=$(OBJ_DIR)/%.o)

TOTAL_FILES := $(words $(SRC_FILES))
COMPILED_FILES := 0

define progress_bar
	@$(eval COMPILED_FILES=$(shell echo $$(($(COMPILED_FILES) + 1))))
	@PROGRESS=$$(($(COMPILED_FILES) * 100 / $(TOTAL_FILES))); \
	BAR=$$(seq -s= $$(($$PROGRESS / 5)) | sed 's/[0-9]//g'); \
	printf "\rCompiling [%-20s] %d%%" "$$BAR" "$$PROGRESS"
endef

all: $(NAME)
	@echo ""

$(NAME): $(OBJS) $(LIBFT) $(MLX)
	@$(CC) $(CFLAGS) -o $(NAME) $(OBJS) $(LIBS) > /dev/null 2>&1

$(OBJ_DIR)/%.o: ./srcs/%.c | $(OBJ_DIR)
	@mkdir -p $(dir $@)
	@$(CC) $(CFLAGS) -c $< -o $@
	$(call progress_bar)

$(OBJ_DIR):
	@mkdir -p $(OBJ_DIR)/main
	@mkdir -p $(OBJ_DIR)/parsing
	@mkdir -p $(OBJ_DIR)/raycasting
	@mkdir -p $(OBJ_DIR)/game
	@mkdir -p $(OBJ_DIR)/graphics

$(LIBFT):
	@make --no-print-directory -C $(LIBFT_DIR) > /dev/null

$(MLX):
	@make -s --no-print-directory -C $(MLX_DIR) > /dev/null 2>&1

clean:
	@rm -rf $(OBJ_DIR)
	@make clean --no-print-directory -C $(LIBFT_DIR) > /dev/null
	@make clean --no-print-directory -C $(MLX_DIR) > /dev/null 2>&1

fclean: clean
	@rm -f $(NAME)
	@make fclean --no-print-directory -C $(LIBFT_DIR) > /dev/null

re: fclean all

.PHONY: all clean fclean re